{
	"Language": "Vyper",
	"Source": "# Burni (based on the ERC-20 specification)\r\n# https://burni.co\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n# Used to verify a transfer into a smart contract.\r\ncontract ERC20Receiver:\r\n\tdef onERC20Received(_from: address, _value: uint256) -> bytes32: modifying\r\n\r\n# Events\r\nTransfer: event({_from: indexed(address), _to: indexed(address), _value: uint256})\r\nApproval: event({_owner: indexed(address), _spender: indexed(address), _value: uint256})\r\n\r\nallowances: map(address, map(address, uint256))\r\ntotal_supply: uint256      # 1b\r\nname: public(string[64])   # Burni\r\nsymbol: public(string[32]) # BURN\r\ndecimals: public(uint256)  # 18 (similar to Wei)\r\nbalanceOf: public(map(address, uint256))\r\n\r\n@public\r\ndef __init__(_name: string[64], _symbol: string[32], _decimals: uint256, _supply: uint256):\r\n\t# Define the token and mint the initial supply.\r\n\tinit_supply: uint256 = _supply * 10 ** _decimals\r\n\r\n\tself.name = _name\r\n\tself.symbol = _symbol\r\n\tself.decimals = _decimals\r\n\tself.balanceOf[msg.sender] = init_supply\r\n\tself.total_supply = init_supply\r\n\tlog.Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n@public\r\n@constant\r\ndef totalSupply() -> uint256:\r\n\t# The total supply will gradually decrease as tokens are burnt.\r\n\treturn self.total_supply\r\n\r\n@public\r\n@constant\r\ndef allowance(_owner: address, _spender: address) -> uint256:\r\n\t# Check the amount of Burni allowed to a spender.\r\n\treturn self.allowances[_owner][_spender]\r\n\r\n@public\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n\t# Transfer from msg.sender to _to (reverts on insufficient msg.sender balance.)\r\n\tself.balanceOf[msg.sender] -= _value\r\n\tself.balanceOf[_to] += _value\r\n\r\n\tif _to.is_contract:\r\n\t\t# Check the method signature when transfering tokens to a contract (eg. Burnin).\r\n\t\treturnValue: bytes32 = ERC20Receiver(_to).onERC20Received(msg.sender, _value)\r\n\t\tassert returnValue == method_id(\"onERC20Received(address,uint256)\", bytes32)\r\n\r\n\t# Emit Transfer event.\r\n\tlog.Transfer(msg.sender, _to, _value)\r\n\treturn True\r\n\r\n@public\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n\t# Transfer from one account to another (reverts if insufficient allowance or funds.)\r\n\tself.allowances[_from][msg.sender] -= _value\r\n\tself.balanceOf[_from] -= _value\r\n\tself.balanceOf[_to] += _value\r\n\tlog.Transfer(_from, _to, _value)\r\n\treturn True\r\n\r\n@public\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n\t# Approve a new spender / burner.\r\n\tself.allowances[msg.sender][_spender] = _value\r\n\tlog.Approval(msg.sender, _spender, _value)\r\n\treturn True\r\n\r\n@private\r\ndef _burn(_to: address, _value: uint256):\r\n\t# Removes tokens from circulation (only 2.5% are spared with Burnin minting).\r\n\tassert _to != ZERO_ADDRESS\r\n\tself.total_supply -= _value\r\n\tself.balanceOf[_to] -= _value\r\n\tlog.Transfer(_to, ZERO_ADDRESS, _value)\r\n\r\n@public\r\ndef burn(_value: uint256):\r\n\t# Burn the tokens, reducing the total supply.\r\n\tself._burn(msg.sender, _value)\r\n\r\n@public\r\ndef burnFrom(_to: address, _value: uint256):\r\n\t# Burn from an allowed burner.\r\n\tself.allowances[_to][msg.sender] -= _value\r\n\tself._burn(_to, _value)",
	"ContractName": "Vyper_contract"
}