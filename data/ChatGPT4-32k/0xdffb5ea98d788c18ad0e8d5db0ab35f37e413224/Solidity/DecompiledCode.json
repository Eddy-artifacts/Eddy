{
	"address": "0xdffb5ea98d788c18ad0e8d5db0ab35f37e413224",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity smart contract that closely resembles the given decompiled code:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract YourContract {\n    mapping (uint256 => uint256[]) private _checkInvestments;\n    mapping (uint256 => uint256[]) private owner_1;\n    mapping (uint256 => uint256[]) private _checkWithdrawals;\n    mapping (uint256 => uint256[]) private _checkWithdrawalsgross;\n    mapping (uint256 => uint256[]) private _checkReferral;\n    uint256 private _step;\n    uint256 private _bankrollpercentage;\n    uint256 private _maximumpercent;\n    uint256 private _minimum;\n    uint256 private _stakingRequirement;\n    uint256 private _startTime;\n    uint256 private stor_b; \n    uint256 private stor_e;\n    address private _ownerWallet;\n    address private _setBankrollpercentage;\n    address private stor_f_0_19;\n    address private stor_10_0_19;\n    address private stor_11_0_19;\n    address private stor_12_0_19;\n    address private stor_13_0_19;\n    address private stor_14_0_19;\n    address private stor_15_0_19;\n    address private stor_16_0_19;\n    address private stor_17_0_19;\n\n    event Invest(address indexed sender, uint256 value);\n    event Withdraw(address indexed sender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Bounty(address indexed sender, uint256 value);\n    event Lottery(address indexed sender, uint256 value, uint256, uint256, bool);\n\n    // Private functions\n    function func_1134(uint256 varg0, uint256 varg1) private pure returns (uint256) {\n        //Implementation Missing\n        return 0;\n    }\n\n    function _SafeAdd(uint256 varg0, uint256 varg1) private pure returns (uint256) {\n        //Implementation Missing\n        return 0;\n    }\n\n    function func_48b() private {\n        //Implementation Missing\n    }\n\n    function func_8d1() private {\n        //Implementation Missing\n    }\n\n    function func_fa5(uint256 varg0) private returns (uint256) {\n        //Implementation Missing\n        return 0;\n    }\n\n    // Public functions\n    function fallback() public payable {\n        func_48b();\n    }\n\n    function checkReferral(address varg0) public view returns (uint256[] memory) {\n        return _checkReferral[uint256(varg0)];\n    }\n\n    function setBankrollpercentage(uint256 varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        _bankrollpercentage = varg0;\n    }\n\n    function withdraw() public {\n        func_8d1();\n    }\n\n    function setStartTime(uint256 varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        _startTime = varg0;\n    }\n\n    function setYoutuber2(address varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_13_0_19 = varg0;\n    }\n\n    function checkContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function minimum() public view returns (uint256) {\n        return _minimum;\n    }\n\n    function stakingRequirement() public view returns (uint256) {\n        return _stakingRequirement;\n    }\n\n    function bankrollpercentage() public view returns (uint256) {\n        return _bankrollpercentage;\n    }\n\n    function transferOwnership(address varg0, address varg1) public {\n        require(msg.sender == _setBankrollpercentage);\n        require(varg0 != address(0));\n        emit OwnershipTransferred(_setBankrollpercentage, varg0);\n        _setBankrollpercentage = varg0;\n        _ownerWallet = varg1;\n    }\n\n    function startTime() public view returns (uint256) {\n        return _startTime;\n    }\n\n    function setYoutuber5(address varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_16_0_19 = varg0;\n    }\n\n    function checkInvestments(address varg0) public view returns (uint256[] memory) {\n        return _checkInvestments[uint256(varg0)];\n    }\n\n    function checkWithdrawalsgross(address varg0) public view returns (uint256[] memory) {\n        return _checkWithdrawalsgross[uint256(varg0)];\n    }\n\n    function owner() public view returns (address) {\n        return _setBankrollpercentage;\n    }\n\n    function ownerWallet() public view returns (address) {\n        return _ownerWallet;\n    }\n\n    function bounty() public {\n        //Implementation Missing\n    }\n\n    function setYoutuber1(address varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_12_0_19 = varg0;\n    }\n\n    function checkWithdrawals(address varg0) public view returns (uint256[] memory) {\n        return _checkWithdrawals[uint256(varg0)];\n    }\n\n    function setRandomizer(uint256 varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_e = varg0;\n    }\n\n    function lottery(uint256 varg0) public payable {\n        //Implementation Missing\n    }\n\n    function setYoutuber4(address varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_15_0_19 = varg0;\n    }\n\n    function setYoutuber3(address varg0) public {\n        require(msg.sender == _setBankrollpercentage);\n        stor_14_0_19 = varg0;\n    }\n\n    function checkBalance() public returns (uint256) {\n        return func_fa5(uint256(msg.sender));\n    }\n\n    function step() public view returns (uint256) {\n        return _step;\n    }\n\n    function buy(address varg0) public payable {\n        func_48b();\n    }\n\n    function getBalance(address varg0) public returns (uint256) {\n        return func_fa5(uint256(varg0));\n    }\n\n    function maximumpercent() public view returns (uint256) {\n        return _maximumpercent;\n    }\n}\n```\n\nPlease note that some functions are not completely implemented because the decompiled code is not complete or not clear enough to derive the correct implementation. You should replace `//Implementation Missing` with the actual implementation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701471041,
	"id": "chatcmpl-8R6dF0qMIuYyfCLGOyDqbqoR4np4H",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 21:14 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkWithdrawalsgross; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\nuint256 _bankrollpercentage; // STORAGE[0x6]\nuint256 _maximumpercent; // STORAGE[0x7]\nuint256 _minimum; // STORAGE[0x8]\nuint256 _stakingRequirement; // STORAGE[0x9]\nuint256 _startTime; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_e; // STORAGE[0xe]\naddress _ownerWallet; // STORAGE[0xc] bytes 0 to 19\naddress _setBankrollpercentage; // STORAGE[0xd] bytes 0 to 19\naddress stor_f_0_19; // STORAGE[0xf] bytes 0 to 19\naddress stor_10_0_19; // STORAGE[0x10] bytes 0 to 19\naddress stor_11_0_19; // STORAGE[0x11] bytes 0 to 19\naddress stor_12_0_19; // STORAGE[0x12] bytes 0 to 19\naddress stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\naddress stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\naddress stor_15_0_19; // STORAGE[0x15] bytes 0 to 19\naddress stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\naddress stor_17_0_19; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\nLottery(address, uint256, uint256, uint256, bool);\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x48b();\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction setBankrollpercentage(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _bankrollpercentage = varg0;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x8d1();\n    return v0;\n}\n\nfunction setStartTime(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _startTime = varg0;\n}\n\nfunction setYoutuber2(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_13_0_19 = varg0;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction bankrollpercentage() public nonPayable { \n    return _bankrollpercentage;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    require(varg0);\n    emit OwnershipTransferred(_setBankrollpercentage, varg0);\n    _setBankrollpercentage = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction setYoutuber5(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_16_0_19 = varg0;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction checkWithdrawalsgross(address varg0) public nonPayable { \n    return _checkWithdrawalsgross[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setBankrollpercentage;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction setYoutuber1(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_12_0_19 = varg0;\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction setRandomizer(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_e = varg0;\n}\n\nfunction lottery(uint256 varg0) public payable { \n    v0 = v1 = 371;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = v5 = 3400;\n    v6 = v7 = 100;\n    v8 = v9 = 0x1134(_bankrollpercentage, (address(this)).balance);\n    while (!v6) {\n        assert(v6);\n        v10 = v0.call().value(v11).gas(v0 * !v11);\n        require(v10); // checks call status, propagates error data on error\n        emit Lottery(msg.sender, v0, msg.value, v0, v0);\n        exit;\n        v0 = v11 = v8 / v6;\n        goto {'0xe85', '0xd8b', '0xd48', '0xe37', '0xde9'};\n        require(v11 >= msg.value);\n        stor_b += 1;\n        MEM[MEM[64] + 32] = block.timestamp;\n        MEM[64 + MEM[64]] = msg.sender << 96;\n        MEM[MEM[64] + 84] = 1 + stor_b;\n        MEM[MEM[64] + 116] = stor_e;\n        MEM[MEM[64] + 148] = block.coinbase << 96;\n        MEM[MEM[64] + 168] = block.number;\n        v12 = v13 = MEM[64] + 200;\n        v14 = v15 = 168;\n        v16 = v17 = MEM[64] + 32;\n        while (v14 >= 32) {\n            MEM[v12] = MEM[v16];\n            v14 = v14 + ~31;\n            v12 += 32;\n            v16 += 32;\n        }\n        MEM[v12] = MEM[v12] & ~0 + 256 ** (32 - v14) | MEM[v16] & ~(~0 + 256 ** (32 - v14));\n        assert(7);\n        v0 = v18 = 1 + keccak256(v19.data) % 7;\n        v0 = v20 = 0;\n        if (v18 == v0) {\n            v0 = v21 = 1;\n            v4 = v22 = 3467;\n            v6 = v23 = 100;\n            v8 = v24 = 0x1134(180, msg.value);\n        }\n        if (v11 <= this.balance) {\n            v25 = msg.sender.call().value(v11).gas(2300 * !v11);\n            require(v25); // checks call status, propagates error data on error\n        }\n        v0 = v26 = _ownerWallet;\n        v0 = v27 = 2300;\n        v4 = v28 = 3561;\n        v6 = v29 = 100;\n        v8 = v30 = 0x1134(5, msg.value);\n        v31 = v0.call().value(v11).gas(v0 * !v11);\n        require(v31); // checks call status, propagates error data on error\n        v0 = v32 = stor_17_0_19;\n        v0 = v33 = 2300;\n        v4 = v34 = 3639;\n        v6 = v35 = 100;\n        v8 = v36 = 0x1134(3, msg.value);\n        v37 = v0.call().value(v11).gas(v0 * !v11);\n        require(v37); // checks call status, propagates error data on error\n        v0 = v38 = stor_f_0_19;\n        v0 = v39 = 2300;\n        v4 = v40 = 3717;\n        v6 = v41 = 100;\n        v8 = v42 = 0x1134(2, msg.value);\n    }\n}\n\nfunction setYoutuber4(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_15_0_19 = varg0;\n}\n\nfunction setYoutuber3(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_14_0_19 = varg0;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xfa5(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x48b();\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xfa5(varg0);\n    return v0;\n}\n\nfunction maximumpercent() public nonPayable { \n    return _maximumpercent;\n}\n\nfunction 0x48b() private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (block.timestamp <= _startTime) {\n        require(msg.sender == _setBankrollpercentage);\n    }\n    require(msg.value >= _minimum);\n    v0 = v4 = msg.sender;\n    v5 = !address(v0);\n    v6 = v7 = address(v0);\n    if (address(v0)) {\n        v6 = v8 = address(v0) != address(v4);\n    }\n    if (v6) {\n        v9 = address(v0);\n        v6 = v10 = _checkInvestments[v9] >= _stakingRequirement;\n    }\n    if (v6) {\n        v0 = v11 = 1382;\n        v12 = v13 = 1345;\n        v14 = v15 = 100;\n        v16 = v17 = 0x1134(5, msg.value);\n    }\n    while (!v14) {\n        assert(v14);\n        v18 = address(v0);\n        v19 = _SafeAdd(v20, _checkReferral[v18]);\n        v21 = address(v0);\n        _checkReferral[v21] = v19;\n        assert(2);\n        v22 = _ownerWallet.call().value(v0).gas(2300 * !v0);\n        require(v22); // checks call status, propagates error data on error\n        v23 = stor_f_0_19.call().value(v0).gas(2300 * !v0);\n        require(v23); // checks call status, propagates error data on error\n        v24 = stor_10_0_19.call().value(v20).gas(2300 * !v20);\n        require(v24); // checks call status, propagates error data on error\n        v25 = stor_11_0_19.call().value(v20).gas(2300 * !v20);\n        require(v25); // checks call status, propagates error data on error\n        v26 = stor_12_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v26); // checks call status, propagates error data on error\n        v27 = stor_13_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v27); // checks call status, propagates error data on error\n        v28 = stor_14_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v28); // checks call status, propagates error data on error\n        v29 = stor_15_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v29); // checks call status, propagates error data on error\n        v30 = stor_16_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v30); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n        return ;\n        v0 = v20 = v16 / v14;\n        goto {'0x606', '0x631', '0x541'};\n        assert(2);\n        v0 = v31 = v20 >> 1;\n        v12 = v32 = 1585;\n        v14 = v33 = 100;\n        v16 = v34 = 0x1134(1, msg.value);\n    }\n    if (_checkInvestments[msg.sender] > 0) {\n        v35 = 0x8d1();\n        if (v35) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v36 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v36;\n    owner_1[msg.sender] = block.timestamp;\n    v12 = v37 = 1542;\n    v14 = v38 = 100;\n    v16 = v39 = 0x1134(5, msg.value);\n}\n\nfunction 0x8d1() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0xfa5(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = _SafeAdd(v0, _checkWithdrawalsgross[msg.sender]);\n            _checkWithdrawalsgross[msg.sender] = v4;\n            v5 = 0x1134(_maximumpercent, _checkWithdrawalsgross[msg.sender]);\n            assert(100);\n            v6 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v6); // checks call status, propagates error data on error\n            if (v5 / 100 <= _checkWithdrawalsgross[msg.sender]) {\n                _checkInvestments[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n            }\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v7 = 1;\n    }\n    return v1;\n}\n\nfunction 0xfa5(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 4080;\n    v6 = v7 = 60;\n    v8 = address(varg0);\n    assert(owner_1[v8] <= block.timestamp);\n    v9 = block.timestamp - owner_1[v8];\n    while (!v6) {\n        assert(v6);\n        v10 = address(varg0);\n        v11 = _SafeAdd(v2, _checkWithdrawalsgross[v10]);\n        if (v11 > v0) {\n            v12 = address(varg0);\n            assert(_checkWithdrawalsgross[v12] <= v0);\n            v2 = v0 - _checkWithdrawalsgross[v12];\n        }\n        return v2;\n        v0 = v9 / v6;\n        goto {'0xff0', '0x1026', '0x10b4', '0x1051'};\n        v13 = address(varg0);\n        v4 = v14 = 4134;\n        v6 = v15 = 100;\n        v9 = v16 = 0x1134(_step, _checkInvestments[v13]);\n        assert(2);\n        v4 = v17 = 4177;\n        v6 = v18 = 1440;\n        v9 = 0x1134(v0, v0 >> 1);\n        v19 = address(varg0);\n        assert(_checkWithdrawals[v19] <= v0);\n        v2 = v20 = v0 - _checkWithdrawals[v19];\n        v21 = address(varg0);\n        v4 = v22 = 4276;\n        v6 = v23 = 100;\n        v9 = v24 = 0x1134(_maximumpercent, _checkInvestments[v21]);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x1de7f3e3 == function_selector) {\n            setBankrollpercentage(uint256);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x3e0a322d == function_selector) {\n            setStartTime(uint256);\n        } else if (0x3ee75dc7 == function_selector) {\n            setYoutuber2(address);\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6016dd0a == function_selector) {\n            bankrollpercentage();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8273b012 == function_selector) {\n            setYoutuber5(address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8a7097ce == function_selector) {\n            checkWithdrawalsgross(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9c326fa3 == function_selector) {\n            setYoutuber1(address);\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xa3e4c0c4 == function_selector) {\n            setRandomizer(uint256);\n        } else if (0xa57d1560 == function_selector) {\n            lottery(uint256);\n        } else if (0xa7bd0338 == function_selector) {\n            setYoutuber4(address);\n        } else if (0xbb6a47f1 == function_selector) {\n            setYoutuber3(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        } else if (0xf9a2be99 == function_selector) {\n            maximumpercent();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 21:14 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkWithdrawalsgross; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\nuint256 _bankrollpercentage; // STORAGE[0x6]\nuint256 _maximumpercent; // STORAGE[0x7]\nuint256 _minimum; // STORAGE[0x8]\nuint256 _stakingRequirement; // STORAGE[0x9]\nuint256 _startTime; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_e; // STORAGE[0xe]\naddress _ownerWallet; // STORAGE[0xc] bytes 0 to 19\naddress _setBankrollpercentage; // STORAGE[0xd] bytes 0 to 19\naddress stor_f_0_19; // STORAGE[0xf] bytes 0 to 19\naddress stor_10_0_19; // STORAGE[0x10] bytes 0 to 19\naddress stor_11_0_19; // STORAGE[0x11] bytes 0 to 19\naddress stor_12_0_19; // STORAGE[0x12] bytes 0 to 19\naddress stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\naddress stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\naddress stor_15_0_19; // STORAGE[0x15] bytes 0 to 19\naddress stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\naddress stor_17_0_19; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\nLottery(address, uint256, uint256, uint256, bool);\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x48b();\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction setBankrollpercentage(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _bankrollpercentage = varg0;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x8d1();\n    return v0;\n}\n\nfunction setStartTime(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _startTime = varg0;\n}\n\nfunction setYoutuber2(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_13_0_19 = varg0;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction bankrollpercentage() public nonPayable { \n    return _bankrollpercentage;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    require(varg0);\n    emit OwnershipTransferred(_setBankrollpercentage, varg0);\n    _setBankrollpercentage = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction setYoutuber5(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_16_0_19 = varg0;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction checkWithdrawalsgross(address varg0) public nonPayable { \n    return _checkWithdrawalsgross[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setBankrollpercentage;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction setYoutuber1(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_12_0_19 = varg0;\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction setRandomizer(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_e = varg0;\n}\n\nfunction lottery(uint256 varg0) public payable { \n    v0 = v1 = 371;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = v5 = 3400;\n    v6 = v7 = 100;\n    v8 = v9 = 0x1134(_bankrollpercentage, (address(this)).balance);\n    while (!v6) {\n        assert(v6);\n        v10 = v0.call().value(v11).gas(v0 * !v11);\n        require(v10); // checks call status, propagates error data on error\n        emit Lottery(msg.sender, v0, msg.value, v0, v0);\n        exit;\n        v0 = v11 = v8 / v6;\n        goto {'0xe85', '0xd8b', '0xd48', '0xe37', '0xde9'};\n        require(v11 >= msg.value);\n        stor_b += 1;\n        MEM[MEM[64] + 32] = block.timestamp;\n        MEM[64 + MEM[64]] = msg.sender << 96;\n        MEM[MEM[64] + 84] = 1 + stor_b;\n        MEM[MEM[64] + 116] = stor_e;\n        MEM[MEM[64] + 148] = block.coinbase << 96;\n        MEM[MEM[64] + 168] = block.number;\n        v12 = v13 = MEM[64] + 200;\n        v14 = v15 = 168;\n        v16 = v17 = MEM[64] + 32;\n        while (v14 >= 32) {\n            MEM[v12] = MEM[v16];\n            v14 = v14 + ~31;\n            v12 += 32;\n            v16 += 32;\n        }\n        MEM[v12] = MEM[v12] & ~0 + 256 ** (32 - v14) | MEM[v16] & ~(~0 + 256 ** (32 - v14));\n        assert(7);\n        v0 = v18 = 1 + keccak256(v19.data) % 7;\n        v0 = v20 = 0;\n        if (v18 == v0) {\n            v0 = v21 = 1;\n            v4 = v22 = 3467;\n            v6 = v23 = 100;\n            v8 = v24 = 0x1134(180, msg.value);\n        }\n        if (v11 <= this.balance) {\n            v25 = msg.sender.call().value(v11).gas(2300 * !v11);\n            require(v25); // checks call status, propagates error data on error\n        }\n        v0 = v26 = _ownerWallet;\n        v0 = v27 = 2300;\n        v4 = v28 = 3561;\n        v6 = v29 = 100;\n        v8 = v30 = 0x1134(5, msg.value);\n        v31 = v0.call().value(v11).gas(v0 * !v11);\n        require(v31); // checks call status, propagates error data on error\n        v0 = v32 = stor_17_0_19;\n        v0 = v33 = 2300;\n        v4 = v34 = 3639;\n        v6 = v35 = 100;\n        v8 = v36 = 0x1134(3, msg.value);\n        v37 = v0.call().value(v11).gas(v0 * !v11);\n        require(v37); // checks call status, propagates error data on error\n        v0 = v38 = stor_f_0_19;\n        v0 = v39 = 2300;\n        v4 = v40 = 3717;\n        v6 = v41 = 100;\n        v8 = v42 = 0x1134(2, msg.value);\n    }\n}\n\nfunction setYoutuber4(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_15_0_19 = varg0;\n}\n\nfunction setYoutuber3(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_14_0_19 = varg0;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xfa5(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x48b();\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xfa5(varg0);\n    return v0;\n}\n\nfunction maximumpercent() public nonPayable { \n    return _maximumpercent;\n}\n\nfunction 0x48b() private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (block.timestamp <= _startTime) {\n        require(msg.sender == _setBankrollpercentage);\n    }\n    require(msg.value >= _minimum);\n    v0 = v4 = msg.sender;\n    v5 = !address(v0);\n    v6 = v7 = address(v0);\n    if (address(v0)) {\n        v6 = v8 = address(v0) != address(v4);\n    }\n    if (v6) {\n        v9 = address(v0);\n        v6 = v10 = _checkInvestments[v9] >= _stakingRequirement;\n    }\n    if (v6) {\n        v0 = v11 = 1382;\n        v12 = v13 = 1345;\n        v14 = v15 = 100;\n        v16 = v17 = 0x1134(5, msg.value);\n    }\n    while (!v14) {\n        assert(v14);\n        v18 = address(v0);\n        v19 = _SafeAdd(v20, _checkReferral[v18]);\n        v21 = address(v0);\n        _checkReferral[v21] = v19;\n        assert(2);\n        v22 = _ownerWallet.call().value(v0).gas(2300 * !v0);\n        require(v22); // checks call status, propagates error data on error\n        v23 = stor_f_0_19.call().value(v0).gas(2300 * !v0);\n        require(v23); // checks call status, propagates error data on error\n        v24 = stor_10_0_19.call().value(v20).gas(2300 * !v20);\n        require(v24); // checks call status, propagates error data on error\n        v25 = stor_11_0_19.call().value(v20).gas(2300 * !v20);\n        require(v25); // checks call status, propagates error data on error\n        v26 = stor_12_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v26); // checks call status, propagates error data on error\n        v27 = stor_13_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v27); // checks call status, propagates error data on error\n        v28 = stor_14_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v28); // checks call status, propagates error data on error\n        v29 = stor_15_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v29); // checks call status, propagates error data on error\n        v30 = stor_16_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v30); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n        return ;\n        v0 = v20 = v16 / v14;\n        goto {'0x606', '0x631', '0x541'};\n        assert(2);\n        v0 = v31 = v20 >> 1;\n        v12 = v32 = 1585;\n        v14 = v33 = 100;\n        v16 = v34 = 0x1134(1, msg.value);\n    }\n    if (_checkInvestments[msg.sender] > 0) {\n        v35 = 0x8d1();\n        if (v35) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v36 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v36;\n    owner_1[msg.sender] = block.timestamp;\n    v12 = v37 = 1542;\n    v14 = v38 = 100;\n    v16 = v39 = 0x1134(5, msg.value);\n}\n\nfunction 0x8d1() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0xfa5(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = _SafeAdd(v0, _checkWithdrawalsgross[msg.sender]);\n            _checkWithdrawalsgross[msg.sender] = v4;\n            v5 = 0x1134(_maximumpercent, _checkWithdrawalsgross[msg.sender]);\n            assert(100);\n            v6 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v6); // checks call status, propagates error data on error\n            if (v5 / 100 <= _checkWithdrawalsgross[msg.sender]) {\n                _checkInvestments[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n            }\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v7 = 1;\n    }\n    return v1;\n}\n\nfunction 0xfa5(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 4080;\n    v6 = v7 = 60;\n    v8 = address(varg0);\n    assert(owner_1[v8] <= block.timestamp);\n    v9 = block.timestamp - owner_1[v8];\n    while (!v6) {\n        assert(v6);\n        v10 = address(varg0);\n        v11 = _SafeAdd(v2, _checkWithdrawalsgross[v10]);\n        if (v11 > v0) {\n            v12 = address(varg0);\n            assert(_checkWithdrawalsgross[v12] <= v0);\n            v2 = v0 - _checkWithdrawalsgross[v12];\n        }\n        return v2;\n        v0 = v9 / v6;\n        goto {'0xff0', '0x1026', '0x10b4', '0x1051'};\n        v13 = address(varg0);\n        v4 = v14 = 4134;\n        v6 = v15 = 100;\n        v9 = v16 = 0x1134(_step, _checkInvestments[v13]);\n        assert(2);\n        v4 = v17 = 4177;\n        v6 = v18 = 1440;\n        v9 = 0x1134(v0, v0 >> 1);\n        v19 = address(varg0);\n        assert(_checkWithdrawals[v19] <= v0);\n        v2 = v20 = v0 - _checkWithdrawals[v19];\n        v21 = address(varg0);\n        v4 = v22 = 4276;\n        v6 = v23 = 100;\n        v9 = v24 = 0x1134(_maximumpercent, _checkInvestments[v21]);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x1de7f3e3 == function_selector) {\n            setBankrollpercentage(uint256);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x3e0a322d == function_selector) {\n            setStartTime(uint256);\n        } else if (0x3ee75dc7 == function_selector) {\n            setYoutuber2(address);\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6016dd0a == function_selector) {\n            bankrollpercentage();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8273b012 == function_selector) {\n            setYoutuber5(address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8a7097ce == function_selector) {\n            checkWithdrawalsgross(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9c326fa3 == function_selector) {\n            setYoutuber1(address);\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xa3e4c0c4 == function_selector) {\n            setRandomizer(uint256);\n        } else if (0xa57d1560 == function_selector) {\n            lottery(uint256);\n        } else if (0xa7bd0338 == function_selector) {\n            setYoutuber4(address);\n        } else if (0xbb6a47f1 == function_selector) {\n            setYoutuber3(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        } else if (0xf9a2be99 == function_selector) {\n            maximumpercent();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 21:14 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkWithdrawalsgross; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\nuint256 _bankrollpercentage; // STORAGE[0x6]\nuint256 _maximumpercent; // STORAGE[0x7]\nuint256 _minimum; // STORAGE[0x8]\nuint256 _stakingRequirement; // STORAGE[0x9]\nuint256 _startTime; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_e; // STORAGE[0xe]\naddress _ownerWallet; // STORAGE[0xc] bytes 0 to 19\naddress _setBankrollpercentage; // STORAGE[0xd] bytes 0 to 19\naddress stor_f_0_19; // STORAGE[0xf] bytes 0 to 19\naddress stor_10_0_19; // STORAGE[0x10] bytes 0 to 19\naddress stor_11_0_19; // STORAGE[0x11] bytes 0 to 19\naddress stor_12_0_19; // STORAGE[0x12] bytes 0 to 19\naddress stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\naddress stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\naddress stor_15_0_19; // STORAGE[0x15] bytes 0 to 19\naddress stor_16_0_19; // STORAGE[0x16] bytes 0 to 19\naddress stor_17_0_19; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\nLottery(address, uint256, uint256, uint256, bool);\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x48b();\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction setBankrollpercentage(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _bankrollpercentage = varg0;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x8d1();\n    return v0;\n}\n\nfunction setStartTime(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    _startTime = varg0;\n}\n\nfunction setYoutuber2(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_13_0_19 = varg0;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction bankrollpercentage() public nonPayable { \n    return _bankrollpercentage;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    require(varg0);\n    emit OwnershipTransferred(_setBankrollpercentage, varg0);\n    _setBankrollpercentage = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction setYoutuber5(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_16_0_19 = varg0;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction checkWithdrawalsgross(address varg0) public nonPayable { \n    return _checkWithdrawalsgross[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setBankrollpercentage;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction setYoutuber1(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_12_0_19 = varg0;\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction setRandomizer(uint256 varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_e = varg0;\n}\n\nfunction lottery(uint256 varg0) public payable { \n    v0 = v1 = 371;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v4 = v5 = 3400;\n    v6 = v7 = 100;\n    v8 = v9 = 0x1134(_bankrollpercentage, (address(this)).balance);\n    while (!v6) {\n        assert(v6);\n        v10 = v0.call().value(v11).gas(v0 * !v11);\n        require(v10); // checks call status, propagates error data on error\n        emit Lottery(msg.sender, v0, msg.value, v0, v0);\n        exit;\n        v0 = v11 = v8 / v6;\n        goto {'0xe85', '0xd8b', '0xd48', '0xe37', '0xde9'};\n        require(v11 >= msg.value);\n        stor_b += 1;\n        MEM[MEM[64] + 32] = block.timestamp;\n        MEM[64 + MEM[64]] = msg.sender << 96;\n        MEM[MEM[64] + 84] = 1 + stor_b;\n        MEM[MEM[64] + 116] = stor_e;\n        MEM[MEM[64] + 148] = block.coinbase << 96;\n        MEM[MEM[64] + 168] = block.number;\n        v12 = v13 = MEM[64] + 200;\n        v14 = v15 = 168;\n        v16 = v17 = MEM[64] + 32;\n        while (v14 >= 32) {\n            MEM[v12] = MEM[v16];\n            v14 = v14 + ~31;\n            v12 += 32;\n            v16 += 32;\n        }\n        MEM[v12] = MEM[v12] & ~0 + 256 ** (32 - v14) | MEM[v16] & ~(~0 + 256 ** (32 - v14));\n        assert(7);\n        v0 = v18 = 1 + keccak256(v19.data) % 7;\n        v0 = v20 = 0;\n        if (v18 == v0) {\n            v0 = v21 = 1;\n            v4 = v22 = 3467;\n            v6 = v23 = 100;\n            v8 = v24 = 0x1134(180, msg.value);\n        }\n        if (v11 <= this.balance) {\n            v25 = msg.sender.call().value(v11).gas(2300 * !v11);\n            require(v25); // checks call status, propagates error data on error\n        }\n        v0 = v26 = _ownerWallet;\n        v0 = v27 = 2300;\n        v4 = v28 = 3561;\n        v6 = v29 = 100;\n        v8 = v30 = 0x1134(5, msg.value);\n        v31 = v0.call().value(v11).gas(v0 * !v11);\n        require(v31); // checks call status, propagates error data on error\n        v0 = v32 = stor_17_0_19;\n        v0 = v33 = 2300;\n        v4 = v34 = 3639;\n        v6 = v35 = 100;\n        v8 = v36 = 0x1134(3, msg.value);\n        v37 = v0.call().value(v11).gas(v0 * !v11);\n        require(v37); // checks call status, propagates error data on error\n        v0 = v38 = stor_f_0_19;\n        v0 = v39 = 2300;\n        v4 = v40 = 3717;\n        v6 = v41 = 100;\n        v8 = v42 = 0x1134(2, msg.value);\n    }\n}\n\nfunction setYoutuber4(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_15_0_19 = varg0;\n}\n\nfunction setYoutuber3(address varg0) public nonPayable { \n    require(msg.sender == _setBankrollpercentage);\n    stor_14_0_19 = varg0;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xfa5(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x48b();\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xfa5(varg0);\n    return v0;\n}\n\nfunction maximumpercent() public nonPayable { \n    return _maximumpercent;\n}\n\nfunction 0x48b() private { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    if (block.timestamp <= _startTime) {\n        require(msg.sender == _setBankrollpercentage);\n    }\n    require(msg.value >= _minimum);\n    v0 = v4 = msg.sender;\n    v5 = !address(v0);\n    v6 = v7 = address(v0);\n    if (address(v0)) {\n        v6 = v8 = address(v0) != address(v4);\n    }\n    if (v6) {\n        v9 = address(v0);\n        v6 = v10 = _checkInvestments[v9] >= _stakingRequirement;\n    }\n    if (v6) {\n        v0 = v11 = 1382;\n        v12 = v13 = 1345;\n        v14 = v15 = 100;\n        v16 = v17 = 0x1134(5, msg.value);\n    }\n    while (!v14) {\n        assert(v14);\n        v18 = address(v0);\n        v19 = _SafeAdd(v20, _checkReferral[v18]);\n        v21 = address(v0);\n        _checkReferral[v21] = v19;\n        assert(2);\n        v22 = _ownerWallet.call().value(v0).gas(2300 * !v0);\n        require(v22); // checks call status, propagates error data on error\n        v23 = stor_f_0_19.call().value(v0).gas(2300 * !v0);\n        require(v23); // checks call status, propagates error data on error\n        v24 = stor_10_0_19.call().value(v20).gas(2300 * !v20);\n        require(v24); // checks call status, propagates error data on error\n        v25 = stor_11_0_19.call().value(v20).gas(2300 * !v20);\n        require(v25); // checks call status, propagates error data on error\n        v26 = stor_12_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v26); // checks call status, propagates error data on error\n        v27 = stor_13_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v27); // checks call status, propagates error data on error\n        v28 = stor_14_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v28); // checks call status, propagates error data on error\n        v29 = stor_15_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v29); // checks call status, propagates error data on error\n        v30 = stor_16_0_19.call().value(v20 >> 1).gas(2300 * !(v20 >> 1));\n        require(v30); // checks call status, propagates error data on error\n        emit Invest(msg.sender, msg.value);\n        return ;\n        v0 = v20 = v16 / v14;\n        goto {'0x606', '0x631', '0x541'};\n        assert(2);\n        v0 = v31 = v20 >> 1;\n        v12 = v32 = 1585;\n        v14 = v33 = 100;\n        v16 = v34 = 0x1134(1, msg.value);\n    }\n    if (_checkInvestments[msg.sender] > 0) {\n        v35 = 0x8d1();\n        if (v35) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v36 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v36;\n    owner_1[msg.sender] = block.timestamp;\n    v12 = v37 = 1542;\n    v14 = v38 = 100;\n    v16 = v39 = 0x1134(5, msg.value);\n}\n\nfunction 0x8d1() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0xfa5(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = _SafeAdd(v0, _checkWithdrawalsgross[msg.sender]);\n            _checkWithdrawalsgross[msg.sender] = v4;\n            v5 = 0x1134(_maximumpercent, _checkWithdrawalsgross[msg.sender]);\n            assert(100);\n            v6 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v6); // checks call status, propagates error data on error\n            if (v5 / 100 <= _checkWithdrawalsgross[msg.sender]) {\n                _checkInvestments[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n                _checkWithdrawalsgross[msg.sender] = 0;\n            }\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v7 = 1;\n    }\n    return v1;\n}\n\nfunction 0xfa5(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 4080;\n    v6 = v7 = 60;\n    v8 = address(varg0);\n    assert(owner_1[v8] <= block.timestamp);\n    v9 = block.timestamp - owner_1[v8];\n    while (!v6) {\n        assert(v6);\n        v10 = address(varg0);\n        v11 = _SafeAdd(v2, _checkWithdrawalsgross[v10]);\n        if (v11 > v0) {\n            v12 = address(varg0);\n            assert(_checkWithdrawalsgross[v12] <= v0);\n            v2 = v0 - _checkWithdrawalsgross[v12];\n        }\n        return v2;\n        v0 = v9 / v6;\n        goto {'0xff0', '0x1026', '0x10b4', '0x1051'};\n        v13 = address(varg0);\n        v4 = v14 = 4134;\n        v6 = v15 = 100;\n        v9 = v16 = 0x1134(_step, _checkInvestments[v13]);\n        assert(2);\n        v4 = v17 = 4177;\n        v6 = v18 = 1440;\n        v9 = 0x1134(v0, v0 >> 1);\n        v19 = address(varg0);\n        assert(_checkWithdrawals[v19] <= v0);\n        v2 = v20 = v0 - _checkWithdrawals[v19];\n        v21 = address(varg0);\n        v4 = v22 = 4276;\n        v6 = v23 = 100;\n        v9 = v24 = 0x1134(_maximumpercent, _checkInvestments[v21]);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x1de7f3e3 == function_selector) {\n            setBankrollpercentage(uint256);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x3e0a322d == function_selector) {\n            setStartTime(uint256);\n        } else if (0x3ee75dc7 == function_selector) {\n            setYoutuber2(address);\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6016dd0a == function_selector) {\n            bankrollpercentage();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8273b012 == function_selector) {\n            setYoutuber5(address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8a7097ce == function_selector) {\n            checkWithdrawalsgross(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9c326fa3 == function_selector) {\n            setYoutuber1(address);\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xa3e4c0c4 == function_selector) {\n            setRandomizer(uint256);\n        } else if (0xa57d1560 == function_selector) {\n            lottery(uint256);\n        } else if (0xa7bd0338 == function_selector) {\n            setYoutuber4(address);\n        } else if (0xbb6a47f1 == function_selector) {\n            setYoutuber3(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        } else if (0xf9a2be99 == function_selector) {\n            maximumpercent();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 74.63569116592407,
	"usage": {
		"completion_tokens": 1388,
		"prompt_tokens": 4744,
		"total_tokens": 6132
	}
}