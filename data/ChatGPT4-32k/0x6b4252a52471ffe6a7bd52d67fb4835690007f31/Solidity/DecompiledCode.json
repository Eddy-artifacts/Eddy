{
	"address": "0x6b4252a52471ffe6a7bd52d67fb4835690007f31",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code provided, here is the Solidity contract:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract BEB {\n\n    uint256 private _buyBeb; \n    uint256 private stor_3; \n    mapping (address => uint256) private _bebOf; \n    address private _owner; \n    address private _bebTokenTransfer;\n\n    function getTokenBalance() public view returns (uint256) { \n        return _bebTokenTransfer.balanceOf(address(this));\n    }\n\n    function querBalance() public view returns (uint256) { \n        return address(this).balance;\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function bebOf(address user) public view returns (uint256) { \n        return _bebOf[user];\n    }\n\n    function ETHwithdrawal(uint256 amount) public payable { \n        require(msg.sender == _owner);\n        require(address(this).balance >= amount * 1 ether, 'Insufficient contract balance');\n        (bool success,) = _owner.call{value: amount * 1 ether}(\"\");\n        require(success);\n    }\n\n    function buyBeb() public payable { \n        require(_buyBeb > 0);\n        require(_bebTokenTransfer.balanceOf(address(this)) >= msg.value / _buyBeb);\n        _bebTokenTransfer.transfer(msg.sender, msg.value / _buyBeb);\n    }\n\n    function transferOwnership(address newOwner) public { \n        require(msg.sender == _owner);\n        if (newOwner != address(0)) {\n            _owner = newOwner;\n        }\n    }\n\n    function bebTokenTransfer() public view returns (address) { \n        return _bebTokenTransfer;\n    }\n\n    function setBEBex(uint256 bebPrice, uint256 storageVar) public { \n        require(msg.sender == _owner);\n        _buyBeb = bebPrice;\n        stor_3 = storageVar * 1 ether;\n    }\n\n    receive() external payable { \n    }\n}\n```\n\nPlease note that the actual contract code may vary depending on the specific implementation details, such as the token transfer method or the way the contract handles ownership. Also, the `__function_selector__` function was not translated as Solidity does not support function overloading based on function selector. Instead, different function names should be used for different functionalities.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470524,
	"id": "chatcmpl-8R6UuAvkqqX1O4oOLJ82rbCr2jCvj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 20:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _buyBeb; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _bebOf; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _bebTokenTransfer; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction getTokenBalance() public nonPayable { \n    v0 = 0x337();\n    return v0;\n}\n\nfunction querBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction bebOf(address varg0) public nonPayable { \n    return _bebOf[varg0];\n}\n\nfunction ETHwithdrawal(uint256 varg0) public payable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0 * 0xde0b6b3a7640000, 'Insufficient contract balance');\n    v0 = _owner.call().value(varg0 * 0xde0b6b3a7640000).gas(!(varg0 * 0xde0b6b3a7640000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyBeb() public payable { \n    assert(_buyBeb);\n    v0 = 0x337();\n    require(v0 >= msg.value / _buyBeb);\n    require(_bebTokenTransfer.code.size);\n    v1 = _bebTokenTransfer.transfer(msg.sender, msg.value / _buyBeb).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    if (varg0 != 0) {\n        _owner = varg0;\n    }\n}\n\nfunction 0x337() private { \n    require(_bebTokenTransfer.code.size);\n    v0, v1 = _bebTokenTransfer.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n}\n\nfunction bebTokenTransfer() public nonPayable { \n    return _bebTokenTransfer;\n}\n\nfunction setBEBex(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _buyBeb = varg0;\n    stor_3 = varg1 * 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1dae6529 == function_selector) {\n            bebTokenTransfer();\n        } else if (0x5652748b == function_selector) {\n            setBEBex(uint256,uint256);\n        } else if (0x82b2e257 == function_selector) {\n            getTokenBalance();\n        } else if (0x8a6babac == function_selector) {\n            querBalance();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa8f8c93e == function_selector) {\n            bebOf(address);\n        } else if (0xb55f4eaf == function_selector) {\n            ETHwithdrawal(uint256);\n        } else if (0xeb1b5ec1 == function_selector) {\n            buyBeb();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 20:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _buyBeb; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _bebOf; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _bebTokenTransfer; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction getTokenBalance() public nonPayable { \n    v0 = 0x337();\n    return v0;\n}\n\nfunction querBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction bebOf(address varg0) public nonPayable { \n    return _bebOf[varg0];\n}\n\nfunction ETHwithdrawal(uint256 varg0) public payable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0 * 0xde0b6b3a7640000, 'Insufficient contract balance');\n    v0 = _owner.call().value(varg0 * 0xde0b6b3a7640000).gas(!(varg0 * 0xde0b6b3a7640000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyBeb() public payable { \n    assert(_buyBeb);\n    v0 = 0x337();\n    require(v0 >= msg.value / _buyBeb);\n    require(_bebTokenTransfer.code.size);\n    v1 = _bebTokenTransfer.transfer(msg.sender, msg.value / _buyBeb).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    if (varg0 != 0) {\n        _owner = varg0;\n    }\n}\n\nfunction 0x337() private { \n    require(_bebTokenTransfer.code.size);\n    v0, v1 = _bebTokenTransfer.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n}\n\nfunction bebTokenTransfer() public nonPayable { \n    return _bebTokenTransfer;\n}\n\nfunction setBEBex(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _buyBeb = varg0;\n    stor_3 = varg1 * 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1dae6529 == function_selector) {\n            bebTokenTransfer();\n        } else if (0x5652748b == function_selector) {\n            setBEBex(uint256,uint256);\n        } else if (0x82b2e257 == function_selector) {\n            getTokenBalance();\n        } else if (0x8a6babac == function_selector) {\n            querBalance();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa8f8c93e == function_selector) {\n            bebOf(address);\n        } else if (0xb55f4eaf == function_selector) {\n            ETHwithdrawal(uint256);\n        } else if (0xeb1b5ec1 == function_selector) {\n            buyBeb();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 20:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _buyBeb; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _bebOf; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _bebTokenTransfer; // STORAGE[0x1] bytes 0 to 19\n\n\nfunction getTokenBalance() public nonPayable { \n    v0 = 0x337();\n    return v0;\n}\n\nfunction querBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction bebOf(address varg0) public nonPayable { \n    return _bebOf[varg0];\n}\n\nfunction ETHwithdrawal(uint256 varg0) public payable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg0 * 0xde0b6b3a7640000, 'Insufficient contract balance');\n    v0 = _owner.call().value(varg0 * 0xde0b6b3a7640000).gas(!(varg0 * 0xde0b6b3a7640000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyBeb() public payable { \n    assert(_buyBeb);\n    v0 = 0x337();\n    require(v0 >= msg.value / _buyBeb);\n    require(_bebTokenTransfer.code.size);\n    v1 = _bebTokenTransfer.transfer(msg.sender, msg.value / _buyBeb).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    if (varg0 != 0) {\n        _owner = varg0;\n    }\n}\n\nfunction 0x337() private { \n    require(_bebTokenTransfer.code.size);\n    v0, v1 = _bebTokenTransfer.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction fallback() public payable { \n}\n\nfunction bebTokenTransfer() public nonPayable { \n    return _bebTokenTransfer;\n}\n\nfunction setBEBex(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _buyBeb = varg0;\n    stor_3 = varg1 * 0xde0b6b3a7640000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1dae6529 == function_selector) {\n            bebTokenTransfer();\n        } else if (0x5652748b == function_selector) {\n            setBEBex(uint256,uint256);\n        } else if (0x82b2e257 == function_selector) {\n            getTokenBalance();\n        } else if (0x8a6babac == function_selector) {\n            querBalance();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa8f8c93e == function_selector) {\n            bebOf(address);\n        } else if (0xb55f4eaf == function_selector) {\n            ETHwithdrawal(uint256);\n        } else if (0xeb1b5ec1 == function_selector) {\n            buyBeb();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 18.31510901451111,
	"usage": {
		"completion_tokens": 493,
		"prompt_tokens": 947,
		"total_tokens": 1440
	}
}