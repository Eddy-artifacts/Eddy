{
	"address": "0xa777166242ee46c33994d401e948418ac3992a1f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract that corresponds to the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping(address => uint256) private _checkInvestments;\n    mapping(address => uint256) private _checkWithdrawals;\n    mapping(address => uint256) private _checkReferral;\n    uint256 private _minimum;\n    uint256 private _step;\n    address private _ownerWallet;\n    address private _owner;\n    address private _bountyManager;\n    address private stor_9_0_19;\n\n    event Invest(address investor, uint256 amount);\n    event Withdraw(address user, uint256 amount);\n    event OwnershipTransferred(address previousOwner, address newOwner);\n    event Bounty(address user, uint256 amount);\n\n    function checkReferral(address user) public view returns (uint256) {\n        return _checkReferral[user];\n    }\n\n    function withdraw() public {\n        require(_checkInvestments[msg.sender] > 0);\n        uint256 amount = getBalance(msg.sender);\n        require(amount <= address(this).balance);\n        _checkWithdrawals[msg.sender] += amount;\n        (bool success, ) = msg.sender.call.value(amount)(\"\");\n        require(success);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function minimum() public view returns (uint256) {\n        return _minimum;\n    }\n\n    function transferOwnership(address newOwner, address newOwnerWallet) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        _owner = newOwner;\n        _ownerWallet = newOwnerWallet;\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n\n    function checkInvestments(address user) public view returns (uint256) {\n        return _checkInvestments[user];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function ownerWallet() public view returns (address) {\n        return _ownerWallet;\n    }\n\n    function checkWithdrawals(address user) public view returns (uint256) {\n        return _checkWithdrawals[user];\n    }\n\n    function bountyManager() public view returns (address) {\n        return _bountyManager;\n    }\n\n    function checkBalance() public view returns (uint256) {\n        return getBalance(msg.sender);\n    }\n\n    function updateReferral(address user, uint256 value) public {\n        require(msg.sender == _bountyManager);\n        _checkReferral[user] += value;\n    }\n\n    function step() public view returns (uint256) {\n        return _step;\n    }\n\n    function getBalance(address user) public view returns (uint256) {\n        uint256 balance = _step * _checkInvestments[user] * (now - _checkInvestments[user]) / 60 / 100;\n        if (_checkWithdrawals[user] > balance) {\n            return 0;\n        }\n        return balance - _checkWithdrawals[user];\n    }\n\n    function() external payable {\n        require(msg.value >= _minimum);\n        if (_checkInvestments[msg.sender] > 0) {\n            withdraw();\n            _checkWithdrawals[msg.sender] = 0;\n        }\n        _checkInvestments[msg.sender] += msg.value;\n        (bool success, ) = _ownerWallet.call.value(msg.value * 5 / 100)(\"\");\n        require(success);\n        (success, ) = stor_9_0_19.call.value(msg.value * 5 / 100)(\"\");\n        require(success);\n        emit Invest(msg.sender, msg.value);\n    }\n}\n```\nPlease note that the fallback function is used here instead of the receive function due to the version of solidity being used, which is 0.5.0. In later versions, the receive function is preferred for incoming transactions without data.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470804,
	"id": "chatcmpl-8R6ZQnfrTuMoNAfYRrG9TqWrmB7Bu",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 17:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _minimum; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\naddress _ownerWallet; // STORAGE[0x6] bytes 0 to 19\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _bountyManager; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x7b6();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if ((address(this)).balance > _checkReferral[msg.sender]) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(!_checkReferral[msg.sender] * 2300);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction bountyManager() public nonPayable { \n    return _bountyManager;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xf32(msg.sender);\n    return v0;\n}\n\nfunction updateReferral(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _bountyManager);\n    assert(_checkReferral[varg0] + varg1 >= _checkReferral[varg0]);\n    _checkReferral[varg0] = _checkReferral[varg0] + varg1;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xf32(varg0);\n    return v0;\n}\n\nfunction 0x7b6() private { \n    require(owner_1[msg.sender] > 0);\n    v0 = 0xf32(msg.sender);\n    if ((address(this)).balance <= v0) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            assert(_checkWithdrawals[msg.sender] + v0 >= _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = _checkWithdrawals[msg.sender] + v0;\n            v3 = msg.sender.call().value(v0).gas(!v0 * 2300);\n            require(v3); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction 0x9cd(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= _minimum);\n    if (_checkInvestments[msg.sender] > 0) {\n        v0 = 0x7b6();\n        if (v0) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    assert(_checkInvestments[msg.sender] + msg.value >= _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = _checkInvestments[msg.sender] + msg.value;\n    owner_1[msg.sender] = block.timestamp;\n    assert(100);\n    v1 = 0x9cd(5, msg.value / 100);\n    v2 = _ownerWallet.call().value(v1).gas(!v1 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    assert(100);\n    v3 = 0x9cd(5, msg.value / 100);\n    v4 = stor_9_0_19.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction 0xf32(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(owner_1[v0] <= block.timestamp);\n    assert(60);\n    v1 = address(varg0);\n    v2 = 0x9cd(_step, _checkInvestments[v1]);\n    assert(100);\n    v3 = 0x9cd((block.timestamp - owner_1[v0]) / 60, v2 / 100);\n    assert(1440);\n    v4 = address(varg0);\n    assert(_checkWithdrawals[v4] <= v3 / 1440);\n    return v3 / 1440 - _checkWithdrawals[v4];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc19f80e == function_selector) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xb36b9ffd == function_selector) {\n            bountyManager();\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xd3cde1a5 == function_selector) {\n            updateReferral(address,uint256);\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 17:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _minimum; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\naddress _ownerWallet; // STORAGE[0x6] bytes 0 to 19\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _bountyManager; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x7b6();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if ((address(this)).balance > _checkReferral[msg.sender]) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(!_checkReferral[msg.sender] * 2300);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction bountyManager() public nonPayable { \n    return _bountyManager;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xf32(msg.sender);\n    return v0;\n}\n\nfunction updateReferral(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _bountyManager);\n    assert(_checkReferral[varg0] + varg1 >= _checkReferral[varg0]);\n    _checkReferral[varg0] = _checkReferral[varg0] + varg1;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xf32(varg0);\n    return v0;\n}\n\nfunction 0x7b6() private { \n    require(owner_1[msg.sender] > 0);\n    v0 = 0xf32(msg.sender);\n    if ((address(this)).balance <= v0) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            assert(_checkWithdrawals[msg.sender] + v0 >= _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = _checkWithdrawals[msg.sender] + v0;\n            v3 = msg.sender.call().value(v0).gas(!v0 * 2300);\n            require(v3); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction 0x9cd(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= _minimum);\n    if (_checkInvestments[msg.sender] > 0) {\n        v0 = 0x7b6();\n        if (v0) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    assert(_checkInvestments[msg.sender] + msg.value >= _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = _checkInvestments[msg.sender] + msg.value;\n    owner_1[msg.sender] = block.timestamp;\n    assert(100);\n    v1 = 0x9cd(5, msg.value / 100);\n    v2 = _ownerWallet.call().value(v1).gas(!v1 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    assert(100);\n    v3 = 0x9cd(5, msg.value / 100);\n    v4 = stor_9_0_19.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction 0xf32(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(owner_1[v0] <= block.timestamp);\n    assert(60);\n    v1 = address(varg0);\n    v2 = 0x9cd(_step, _checkInvestments[v1]);\n    assert(100);\n    v3 = 0x9cd((block.timestamp - owner_1[v0]) / 60, v2 / 100);\n    assert(1440);\n    v4 = address(varg0);\n    assert(_checkWithdrawals[v4] <= v3 / 1440);\n    return v3 / 1440 - _checkWithdrawals[v4];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc19f80e == function_selector) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xb36b9ffd == function_selector) {\n            bountyManager();\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xd3cde1a5 == function_selector) {\n            updateReferral(address,uint256);\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 17:08 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _minimum; // STORAGE[0x4]\nuint256 _step; // STORAGE[0x5]\naddress _ownerWallet; // STORAGE[0x6] bytes 0 to 19\naddress _owner; // STORAGE[0x7] bytes 0 to 19\naddress _bountyManager; // STORAGE[0x8] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x7b6();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if ((address(this)).balance > _checkReferral[msg.sender]) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(!_checkReferral[msg.sender] * 2300);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction bountyManager() public nonPayable { \n    return _bountyManager;\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0xf32(msg.sender);\n    return v0;\n}\n\nfunction updateReferral(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _bountyManager);\n    assert(_checkReferral[varg0] + varg1 >= _checkReferral[varg0]);\n    _checkReferral[varg0] = _checkReferral[varg0] + varg1;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0xf32(varg0);\n    return v0;\n}\n\nfunction 0x7b6() private { \n    require(owner_1[msg.sender] > 0);\n    v0 = 0xf32(msg.sender);\n    if ((address(this)).balance <= v0) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            assert(_checkWithdrawals[msg.sender] + v0 >= _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = _checkWithdrawals[msg.sender] + v0;\n            v3 = msg.sender.call().value(v0).gas(!v0 * 2300);\n            require(v3); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v4 = 1;\n    }\n    return v1;\n}\n\nfunction 0x9cd(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(msg.value >= _minimum);\n    if (_checkInvestments[msg.sender] > 0) {\n        v0 = 0x7b6();\n        if (v0) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    assert(_checkInvestments[msg.sender] + msg.value >= _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = _checkInvestments[msg.sender] + msg.value;\n    owner_1[msg.sender] = block.timestamp;\n    assert(100);\n    v1 = 0x9cd(5, msg.value / 100);\n    v2 = _ownerWallet.call().value(v1).gas(!v1 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    assert(100);\n    v3 = 0x9cd(5, msg.value / 100);\n    v4 = stor_9_0_19.call().value(v3).gas(!v3 * 2300);\n    require(v4); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n}\n\nfunction 0xf32(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(owner_1[v0] <= block.timestamp);\n    assert(60);\n    v1 = address(varg0);\n    v2 = 0x9cd(_step, _checkInvestments[v1]);\n    assert(100);\n    v3 = 0x9cd((block.timestamp - owner_1[v0]) / 60, v2 / 100);\n    assert(1440);\n    v4 = address(varg0);\n    assert(_checkWithdrawals[v4] <= v3 / 1440);\n    return v3 / 1440 - _checkWithdrawals[v4];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xc19f80e == function_selector) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xb36b9ffd == function_selector) {\n            bountyManager();\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xd3cde1a5 == function_selector) {\n            updateReferral(address,uint256);\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 33.93873977661133,
	"usage": {
		"completion_tokens": 780,
		"prompt_tokens": 1839,
		"total_tokens": 2619
	}
}