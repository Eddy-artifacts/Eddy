{
	"address": "0x5fafe57bd692d07c4db048558752632210ccddf6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is the corresponding Solidity code for the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.7;\n\ncontract Crowdfunding {\n\n    uint256 private _totalFunding;\n    mapping (address => uint256) private _balanceOf;\n    address private _owner;\n\n    event FundingReceived(address indexed sender, uint256 value, uint256 timestamp);\n\n    constructor(address owner) {\n        _owner = owner;\n    }\n\n    function participantWithdrawIfMinimumFundingNotReached(uint256 amount) public {\n        require(block.timestamp > 0x5ac21b40, \"Withdrawal not allowed yet\");\n        require(_totalFunding < 0x56bc75e2d63100000, \"Minimum funding has been reached\");\n        require(_balanceOf[msg.sender] >= amount, \"Insufficient balance\");\n        require(_balanceOf[msg.sender] - amount <= _balanceOf[msg.sender], \"Underflow error\");\n        _balanceOf[msg.sender] -= amount;\n        (bool success,) = msg.sender.call{value: amount, gas: 2300 * (amount == 0 ? 1 : 0)}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function ownerWithdraw(uint256 amount) public {\n        require(_owner == msg.sender, \"Only owner can withdraw\");\n        require(_totalFunding >= 0x56bc75e2d63100000, \"Minimum funding not yet reached\");\n        (bool success,) = _owner.call{value: amount, gas: 2300 * (amount == 0 ? 1 : 0)}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function ownerClawback() public {\n        require(_owner == msg.sender, \"Only owner can clawback\");\n        require(block.timestamp >= 0x5bda41ff, \"Clawback not allowed yet\");\n        (bool success,) = _owner.call{value: address(this).balance, gas: 2300 * (address(this).balance == 0 ? 1 : 0)}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function totalFunding() public view returns (uint256) {\n        return _totalFunding;\n    }\n\n    function _SafeAdd(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= b, \"Addition overflow\");\n        return c;\n    }\n\n    receive() external payable {\n        require(block.timestamp >= 0x5a8cb681 && block.timestamp <= 0x5ac21b40, \"Funding period is over\");\n        require(msg.value >= 0x16345785d8a0000 && msg.value <= 0x56bc75e2d63100000, \"Invalid amount\");\n        _balanceOf[msg.sender] = _SafeAdd(msg.value, _balanceOf[msg.sender]);\n        _totalFunding = _SafeAdd(msg.value, _totalFunding);\n        emit FundingReceived(msg.sender, msg.value, block.timestamp);\n    }\n}\n```\n\nThis is a basic crowdfunding contract where a participant can withdraw their funds if the minimum funding goal is not reached by a certain date. The owner can withdraw funds once the minimum funding goal is reached. The owner can also clawback all funds from the contract after a certain date.",
				"role": "assistant"
			}
		}
	],
	"created": 1701471008,
	"id": "chatcmpl-8R6ciEWyji9SsWx2iiwmVKAVrBeTT",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 02:35 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalFunding; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction participantWithdrawIfMinimumFundingNotReached(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5ac21b40);\n    require(_totalFunding < 0x56bc75e2d63100000);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(_balanceOf[msg.sender] - varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction ownerWithdraw(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_totalFunding >= 0x56bc75e2d63100000);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction MAX_AMOUNT() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction OWNER_CLAWBACK_DATE() public nonPayable { \n    return 0x5bda41ff;\n}\n\nfunction PRESALE_MAXIMUM_FUNDING() public nonPayable { \n    return 0x3635c9adc5dea00000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerClawback() public nonPayable { \n    require(_owner == msg.sender);\n    require(block.timestamp >= 0x5bda41ff);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction PRESALE_END_DATE() public nonPayable { \n    return 0x5ac21b40;\n}\n\nfunction MIN_AMOUNT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction PRESALE_START_DATE() public nonPayable { \n    return 0x5a8cb681;\n}\n\nfunction totalFunding() public nonPayable { \n    return _totalFunding;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x2350e762) {\n            participantWithdrawIfMinimumFundingNotReached(uint256);\n        } else if (0x33f707d1 == function_selector) {\n            ownerWithdraw(uint256);\n        } else {\n            if (0x475ec95a != function_selector) {\n                if (0x5a4a04a7 == function_selector) {\n                    OWNER_CLAWBACK_DATE();\n                } else if (0x61962265 == function_selector) {\n                    PRESALE_MAXIMUM_FUNDING();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0xb63e93dc == function_selector) {\n                    ownerClawback();\n                } else if (0xb644ee41 == function_selector) {\n                    PRESALE_END_DATE();\n                } else if (0xd40dc870 != function_selector) {\n                    if (0xddbcb5fa == function_selector) {\n                        MIN_AMOUNT();\n                    } else if (0xf0b80000 == function_selector) {\n                        PRESALE_START_DATE();\n                    } else if (0xfe47a8a7 == function_selector) {\n                        totalFunding();\n                    }\n                }\n            }\n            MAX_AMOUNT();\n        }\n    }\n    require(block.timestamp >= 0x5a8cb681);\n    require(block.timestamp <= 0x5ac21b40);\n    require(msg.value >= 0x16345785d8a0000);\n    require(msg.value <= 0x56bc75e2d63100000);\n    v0 = _SafeAdd(msg.value, _totalFunding);\n    require(v0 <= 0x3635c9adc5dea00000);\n    v1 = _SafeAdd(msg.value, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    v2 = _SafeAdd(msg.value, _totalFunding);\n    _totalFunding = v2;\n    emit 0xd0c0c5120500a67dc7f367c4b7f7afc5a39488be49264d6bd4a6c7e19b245ca(msg.sender, msg.value, block.timestamp);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:35 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalFunding; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction participantWithdrawIfMinimumFundingNotReached(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5ac21b40);\n    require(_totalFunding < 0x56bc75e2d63100000);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(_balanceOf[msg.sender] - varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction ownerWithdraw(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_totalFunding >= 0x56bc75e2d63100000);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction MAX_AMOUNT() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction OWNER_CLAWBACK_DATE() public nonPayable { \n    return 0x5bda41ff;\n}\n\nfunction PRESALE_MAXIMUM_FUNDING() public nonPayable { \n    return 0x3635c9adc5dea00000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerClawback() public nonPayable { \n    require(_owner == msg.sender);\n    require(block.timestamp >= 0x5bda41ff);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction PRESALE_END_DATE() public nonPayable { \n    return 0x5ac21b40;\n}\n\nfunction MIN_AMOUNT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction PRESALE_START_DATE() public nonPayable { \n    return 0x5a8cb681;\n}\n\nfunction totalFunding() public nonPayable { \n    return _totalFunding;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x2350e762) {\n            participantWithdrawIfMinimumFundingNotReached(uint256);\n        } else if (0x33f707d1 == function_selector) {\n            ownerWithdraw(uint256);\n        } else {\n            if (0x475ec95a != function_selector) {\n                if (0x5a4a04a7 == function_selector) {\n                    OWNER_CLAWBACK_DATE();\n                } else if (0x61962265 == function_selector) {\n                    PRESALE_MAXIMUM_FUNDING();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0xb63e93dc == function_selector) {\n                    ownerClawback();\n                } else if (0xb644ee41 == function_selector) {\n                    PRESALE_END_DATE();\n                } else if (0xd40dc870 != function_selector) {\n                    if (0xddbcb5fa == function_selector) {\n                        MIN_AMOUNT();\n                    } else if (0xf0b80000 == function_selector) {\n                        PRESALE_START_DATE();\n                    } else if (0xfe47a8a7 == function_selector) {\n                        totalFunding();\n                    }\n                }\n            }\n            MAX_AMOUNT();\n        }\n    }\n    require(block.timestamp >= 0x5a8cb681);\n    require(block.timestamp <= 0x5ac21b40);\n    require(msg.value >= 0x16345785d8a0000);\n    require(msg.value <= 0x56bc75e2d63100000);\n    v0 = _SafeAdd(msg.value, _totalFunding);\n    require(v0 <= 0x3635c9adc5dea00000);\n    v1 = _SafeAdd(msg.value, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    v2 = _SafeAdd(msg.value, _totalFunding);\n    _totalFunding = v2;\n    emit 0xd0c0c5120500a67dc7f367c4b7f7afc5a39488be49264d6bd4a6c7e19b245ca(msg.sender, msg.value, block.timestamp);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:35 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalFunding; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction participantWithdrawIfMinimumFundingNotReached(uint256 varg0) public nonPayable { \n    require(block.timestamp > 0x5ac21b40);\n    require(_totalFunding < 0x56bc75e2d63100000);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(_balanceOf[msg.sender] - varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = msg.sender.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction ownerWithdraw(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(_totalFunding >= 0x56bc75e2d63100000);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction MAX_AMOUNT() public nonPayable { \n    return 0x56bc75e2d63100000;\n}\n\nfunction OWNER_CLAWBACK_DATE() public nonPayable { \n    return 0x5bda41ff;\n}\n\nfunction PRESALE_MAXIMUM_FUNDING() public nonPayable { \n    return 0x3635c9adc5dea00000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerClawback() public nonPayable { \n    require(_owner == msg.sender);\n    require(block.timestamp >= 0x5bda41ff);\n    v0 = _owner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction PRESALE_END_DATE() public nonPayable { \n    return 0x5ac21b40;\n}\n\nfunction MIN_AMOUNT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction PRESALE_START_DATE() public nonPayable { \n    return 0x5a8cb681;\n}\n\nfunction totalFunding() public nonPayable { \n    return _totalFunding;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x2350e762) {\n            participantWithdrawIfMinimumFundingNotReached(uint256);\n        } else if (0x33f707d1 == function_selector) {\n            ownerWithdraw(uint256);\n        } else {\n            if (0x475ec95a != function_selector) {\n                if (0x5a4a04a7 == function_selector) {\n                    OWNER_CLAWBACK_DATE();\n                } else if (0x61962265 == function_selector) {\n                    PRESALE_MAXIMUM_FUNDING();\n                } else if (0x70a08231 == function_selector) {\n                    balanceOf(address);\n                } else if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0xb63e93dc == function_selector) {\n                    ownerClawback();\n                } else if (0xb644ee41 == function_selector) {\n                    PRESALE_END_DATE();\n                } else if (0xd40dc870 != function_selector) {\n                    if (0xddbcb5fa == function_selector) {\n                        MIN_AMOUNT();\n                    } else if (0xf0b80000 == function_selector) {\n                        PRESALE_START_DATE();\n                    } else if (0xfe47a8a7 == function_selector) {\n                        totalFunding();\n                    }\n                }\n            }\n            MAX_AMOUNT();\n        }\n    }\n    require(block.timestamp >= 0x5a8cb681);\n    require(block.timestamp <= 0x5ac21b40);\n    require(msg.value >= 0x16345785d8a0000);\n    require(msg.value <= 0x56bc75e2d63100000);\n    v0 = _SafeAdd(msg.value, _totalFunding);\n    require(v0 <= 0x3635c9adc5dea00000);\n    v1 = _SafeAdd(msg.value, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    v2 = _SafeAdd(msg.value, _totalFunding);\n    _totalFunding = v2;\n    emit 0xd0c0c5120500a67dc7f367c4b7f7afc5a39488be49264d6bd4a6c7e19b245ca(msg.sender, msg.value, block.timestamp);\n}\n.",
	"status": "1",
	"time_cost": 32.25664830207825,
	"usage": {
		"completion_tokens": 736,
		"prompt_tokens": 1223,
		"total_tokens": 1959
	}
}