{
	"address": "0x6ba91780977db9ce9100a8492de162441d875f47",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity smart contract that corresponds to the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract InvestmentContract {\n\n    uint256 private _invested;\n    mapping (address => uint256) private _idle;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => uint256) private _lastRewards;\n    uint256 private _cumulativeRatios;\n    mapping (uint256 => address) private _participants;\n    uint256 private _countParticipants;\n\n    function losingAmount(address participant, uint256 amount) public view returns (uint256) {\n        return _calculateLoss(amount, participant);\n    }\n\n    function idle() public {\n        _idle[msg.sender] = block.timestamp;\n    }\n\n    function participants(uint256 index) public view returns (address) {\n        return _participants[index];\n    }\n\n    function claimRewards() public {\n        uint256 newReward = (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 1e18;\n        _balanceOf[msg.sender] += newReward;\n        _invested += newReward;\n        _lastRewards[msg.sender] = _cumulativeRatios;\n    }\n\n    function lastPing(address participant) public view returns (uint256) {\n        return _idle[participant];\n    }\n\n    function countParticipants() public view returns (uint256) {\n        return _countParticipants;\n    }\n\n    function balanceOf(address participant) public view returns (uint256) {\n        return _balanceOf[participant];\n    }\n\n    function cumulativeRatios() public view returns (uint256) {\n        return _cumulativeRatios;\n    }\n\n    function divest(uint256 amount) public {\n        require(amount <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= amount;\n        _invested -= amount;\n        _lastRewards[msg.sender] = _cumulativeRatios;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function lastRewards(address participant) public view returns (uint256) {\n        return _lastRewards[participant];\n    }\n\n    function poke(address participant) public {\n        require(block.timestamp > _idle[participant] + 14 hours);\n        require(_balanceOf[participant] > 0);\n        uint256 loss = _calculateLoss(_balanceOf[participant] / 10, participant);\n        _balanceOf[participant] -= loss;\n        _invested -= loss;\n        _lastRewards[participant] = _cumulativeRatios;\n        _idle[participant] = block.timestamp;\n    }\n\n    function getReward(address participant) public view returns (uint256) {\n        return (_cumulativeRatios - _lastRewards[participant]) * _lastRewards[participant] / 1e18;\n    }\n\n    function invested() public view returns (uint256) {\n        return _invested;\n    }\n\n    function invest() public payable {\n        if (_idle[msg.sender] == 0) {\n            _participants[_countParticipants] = msg.sender;\n            _countParticipants += 1;\n        }\n        _idle[msg.sender] = block.timestamp;\n        _balanceOf[msg.sender] += msg.value;\n        _invested += msg.value;\n        _lastRewards[msg.sender] = _cumulativeRatios;\n    }\n\n    function _calculateLoss(uint256 amount, address participant) private view returns (uint256) {\n        return amount - amount * 1e18 / _invested * _balanceOf[participant] / 1e18;\n    }\n\n    function _updateCumulativeRatios(uint256 newInvestment) private {\n        if (_invested > 0) {\n            _cumulativeRatios += newInvestment * 1e18 / _invested;\n        }\n    }\n}\n``` \n\nNote: This smart contract code was written based on the decompiled code provided. However, the decompiled code seems to have some issues that are not usually present in a typical Solidity contract. For instance, it has some functions named with hexadecimal numbers, which is not a valid function identifier in Solidity. Also, it contains call to assert with a non-boolean expression, which is not usual in Solidity. Please use this code with caution. \n\nThis contract is about a simple investment system where users can invest, divest, claim rewards, check balances, and other related activities. For the full understanding of the contract, one needs to understand the exact business logic behind these computations.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465781,
	"id": "chatcmpl-8R5GPU1zXDIgBxpHSd7FjuNkJRgvY",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 03:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _idle; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastRewards; // STORAGE[0x3]\nuint256 _cumulativeRatios; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _participants; // STORAGE[0x5]\nuint256 _countParticipants; // STORAGE[0x6]\n\n\nfunction losingAmount(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x3e0(varg1, varg0);\n    return v0;\n}\n\nfunction idle() public payable { \n    assert(!msg.value);\n    _idle[msg.sender] = block.timestamp;\n}\n\nfunction participants(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_participants[varg0]);\n}\n\nfunction claimRewards() public payable { \n    assert(!msg.value);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _invested = _invested + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n}\n\nfunction lastPing(address varg0) public payable { \n    assert(!msg.value);\n    return _idle[varg0];\n}\n\nfunction countParticipants() public payable { \n    assert(!msg.value);\n    return _countParticipants;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction cumulativeRatios() public payable { \n    assert(!msg.value);\n    return _cumulativeRatios;\n}\n\nfunction divest(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (0 - varg0);\n    _invested = _invested + (0 - varg0);\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction lastRewards(address varg0) public payable { \n    assert(!msg.value);\n    return _lastRewards[varg0];\n}\n\nfunction poke(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = block.timestamp > _idle[varg0] + 50400;\n    if (v1) {\n        v0 = _balanceOf[varg0] > 0;\n    }\n    require(v0);\n    v2 = 0x3e0(_balanceOf[varg0] / 10, varg0);\n    0x95b(_invested, _balanceOf[varg0] / 10);\n    _balanceOf[varg0] = _balanceOf[varg0] + (0 - v2);\n    _invested = _invested + (0 - v2);\n    _lastRewards[varg0] = _cumulativeRatios;\n    _idle[varg0] = block.timestamp;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000);\n}\n\nfunction getReward(address varg0) public payable { \n    assert(!msg.value);\n    return (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000;\n}\n\nfunction invested() public payable { \n    assert(!msg.value);\n    return _invested;\n}\n\nfunction invest() public payable { \n    if (_idle[msg.sender] == 0) {\n        _participants[_countParticipants] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _participants[_countParticipants];\n        _countParticipants = _countParticipants + 1;\n    }\n    _idle[msg.sender] = block.timestamp;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _invested = _invested + msg.value;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n}\n\nfunction 0x3e0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(_invested);\n    assert(0xd3c21bcecceda1000000);\n    return varg0 - varg0 * 0xd3c21bcecceda1000000 / _invested * _balanceOf[v0] / 0xd3c21bcecceda1000000;\n}\n\nfunction 0x95b(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        _cumulativeRatios = _cumulativeRatios + varg1 * 0xd3c21bcecceda1000000 / varg0;\n    }\n    return ;\n}\n\nfunction largeConstant() public payable { \n    assert(!msg.value);\n    return 0xd3c21bcecceda1000000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x2171e7c == function_selector) {\n            largeConstant();\n        } else if (0x1f20f762 == function_selector) {\n            losingAmount(address,uint256);\n        } else if (0x3192164f == function_selector) {\n            idle();\n        } else if (0x35c1d349 == function_selector) {\n            participants(uint256);\n        } else if (0x372500ab == function_selector) {\n            claimRewards();\n        } else if (0x4c38661d == function_selector) {\n            lastPing(address);\n        } else if (0x5c52bba7 == function_selector) {\n            countParticipants();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x781e9892 == function_selector) {\n            cumulativeRatios();\n        } else if (0x8ca17995 == function_selector) {\n            divest(uint256);\n        } else if (0x911ffbdb == function_selector) {\n            lastRewards(address);\n        } else if (0xb1a997ac == function_selector) {\n            poke(address);\n        } else if (0xc00007b0 == function_selector) {\n            getReward(address);\n        } else if (0xcafb2202 == function_selector) {\n            invested();\n        } else if (0xe8b5e51f == function_selector) {\n            invest();\n        }\n    }\n    throw();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 03:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _idle; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastRewards; // STORAGE[0x3]\nuint256 _cumulativeRatios; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _participants; // STORAGE[0x5]\nuint256 _countParticipants; // STORAGE[0x6]\n\n\nfunction losingAmount(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x3e0(varg1, varg0);\n    return v0;\n}\n\nfunction idle() public payable { \n    assert(!msg.value);\n    _idle[msg.sender] = block.timestamp;\n}\n\nfunction participants(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_participants[varg0]);\n}\n\nfunction claimRewards() public payable { \n    assert(!msg.value);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _invested = _invested + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n}\n\nfunction lastPing(address varg0) public payable { \n    assert(!msg.value);\n    return _idle[varg0];\n}\n\nfunction countParticipants() public payable { \n    assert(!msg.value);\n    return _countParticipants;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction cumulativeRatios() public payable { \n    assert(!msg.value);\n    return _cumulativeRatios;\n}\n\nfunction divest(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (0 - varg0);\n    _invested = _invested + (0 - varg0);\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction lastRewards(address varg0) public payable { \n    assert(!msg.value);\n    return _lastRewards[varg0];\n}\n\nfunction poke(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = block.timestamp > _idle[varg0] + 50400;\n    if (v1) {\n        v0 = _balanceOf[varg0] > 0;\n    }\n    require(v0);\n    v2 = 0x3e0(_balanceOf[varg0] / 10, varg0);\n    0x95b(_invested, _balanceOf[varg0] / 10);\n    _balanceOf[varg0] = _balanceOf[varg0] + (0 - v2);\n    _invested = _invested + (0 - v2);\n    _lastRewards[varg0] = _cumulativeRatios;\n    _idle[varg0] = block.timestamp;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000);\n}\n\nfunction getReward(address varg0) public payable { \n    assert(!msg.value);\n    return (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000;\n}\n\nfunction invested() public payable { \n    assert(!msg.value);\n    return _invested;\n}\n\nfunction invest() public payable { \n    if (_idle[msg.sender] == 0) {\n        _participants[_countParticipants] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _participants[_countParticipants];\n        _countParticipants = _countParticipants + 1;\n    }\n    _idle[msg.sender] = block.timestamp;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _invested = _invested + msg.value;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n}\n\nfunction 0x3e0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(_invested);\n    assert(0xd3c21bcecceda1000000);\n    return varg0 - varg0 * 0xd3c21bcecceda1000000 / _invested * _balanceOf[v0] / 0xd3c21bcecceda1000000;\n}\n\nfunction 0x95b(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        _cumulativeRatios = _cumulativeRatios + varg1 * 0xd3c21bcecceda1000000 / varg0;\n    }\n    return ;\n}\n\nfunction largeConstant() public payable { \n    assert(!msg.value);\n    return 0xd3c21bcecceda1000000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x2171e7c == function_selector) {\n            largeConstant();\n        } else if (0x1f20f762 == function_selector) {\n            losingAmount(address,uint256);\n        } else if (0x3192164f == function_selector) {\n            idle();\n        } else if (0x35c1d349 == function_selector) {\n            participants(uint256);\n        } else if (0x372500ab == function_selector) {\n            claimRewards();\n        } else if (0x4c38661d == function_selector) {\n            lastPing(address);\n        } else if (0x5c52bba7 == function_selector) {\n            countParticipants();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x781e9892 == function_selector) {\n            cumulativeRatios();\n        } else if (0x8ca17995 == function_selector) {\n            divest(uint256);\n        } else if (0x911ffbdb == function_selector) {\n            lastRewards(address);\n        } else if (0xb1a997ac == function_selector) {\n            poke(address);\n        } else if (0xc00007b0 == function_selector) {\n            getReward(address);\n        } else if (0xcafb2202 == function_selector) {\n            invested();\n        } else if (0xe8b5e51f == function_selector) {\n            invest();\n        }\n    }\n    throw();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 03:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _idle; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _lastRewards; // STORAGE[0x3]\nuint256 _cumulativeRatios; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _participants; // STORAGE[0x5]\nuint256 _countParticipants; // STORAGE[0x6]\n\n\nfunction losingAmount(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x3e0(varg1, varg0);\n    return v0;\n}\n\nfunction idle() public payable { \n    assert(!msg.value);\n    _idle[msg.sender] = block.timestamp;\n}\n\nfunction participants(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_participants[varg0]);\n}\n\nfunction claimRewards() public payable { \n    assert(!msg.value);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _invested = _invested + (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n}\n\nfunction lastPing(address varg0) public payable { \n    assert(!msg.value);\n    return _idle[varg0];\n}\n\nfunction countParticipants() public payable { \n    assert(!msg.value);\n    return _countParticipants;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction cumulativeRatios() public payable { \n    assert(!msg.value);\n    return _cumulativeRatios;\n}\n\nfunction divest(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + (0 - varg0);\n    _invested = _invested + (0 - varg0);\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction lastRewards(address varg0) public payable { \n    assert(!msg.value);\n    return _lastRewards[varg0];\n}\n\nfunction poke(address varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = block.timestamp > _idle[varg0] + 50400;\n    if (v1) {\n        v0 = _balanceOf[varg0] > 0;\n    }\n    require(v0);\n    v2 = 0x3e0(_balanceOf[varg0] / 10, varg0);\n    0x95b(_invested, _balanceOf[varg0] / 10);\n    _balanceOf[varg0] = _balanceOf[varg0] + (0 - v2);\n    _invested = _invested + (0 - v2);\n    _lastRewards[varg0] = _cumulativeRatios;\n    _idle[varg0] = block.timestamp;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000);\n}\n\nfunction getReward(address varg0) public payable { \n    assert(!msg.value);\n    return (_cumulativeRatios - _lastRewards[varg0]) * _lastRewards[varg0] / 0xd3c21bcecceda1000000;\n}\n\nfunction invested() public payable { \n    assert(!msg.value);\n    return _invested;\n}\n\nfunction invest() public payable { \n    if (_idle[msg.sender] == 0) {\n        _participants[_countParticipants] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _participants[_countParticipants];\n        _countParticipants = _countParticipants + 1;\n    }\n    _idle[msg.sender] = block.timestamp;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _invested = _invested + msg.value;\n    _lastRewards[msg.sender] = _cumulativeRatios;\n    0x95b(_invested, (_cumulativeRatios - _lastRewards[msg.sender]) * _lastRewards[msg.sender] / 0xd3c21bcecceda1000000);\n}\n\nfunction 0x3e0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    assert(_invested);\n    assert(0xd3c21bcecceda1000000);\n    return varg0 - varg0 * 0xd3c21bcecceda1000000 / _invested * _balanceOf[v0] / 0xd3c21bcecceda1000000;\n}\n\nfunction 0x95b(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        _cumulativeRatios = _cumulativeRatios + varg1 * 0xd3c21bcecceda1000000 / varg0;\n    }\n    return ;\n}\n\nfunction largeConstant() public payable { \n    assert(!msg.value);\n    return 0xd3c21bcecceda1000000;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x2171e7c == function_selector) {\n            largeConstant();\n        } else if (0x1f20f762 == function_selector) {\n            losingAmount(address,uint256);\n        } else if (0x3192164f == function_selector) {\n            idle();\n        } else if (0x35c1d349 == function_selector) {\n            participants(uint256);\n        } else if (0x372500ab == function_selector) {\n            claimRewards();\n        } else if (0x4c38661d == function_selector) {\n            lastPing(address);\n        } else if (0x5c52bba7 == function_selector) {\n            countParticipants();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x781e9892 == function_selector) {\n            cumulativeRatios();\n        } else if (0x8ca17995 == function_selector) {\n            divest(uint256);\n        } else if (0x911ffbdb == function_selector) {\n            lastRewards(address);\n        } else if (0xb1a997ac == function_selector) {\n            poke(address);\n        } else if (0xc00007b0 == function_selector) {\n            getReward(address);\n        } else if (0xcafb2202 == function_selector) {\n            invested();\n        } else if (0xe8b5e51f == function_selector) {\n            invest();\n        }\n    }\n    throw();\n}\n.",
	"status": "1",
	"time_cost": 38.73632073402405,
	"usage": {
		"completion_tokens": 942,
		"prompt_tokens": 1799,
		"total_tokens": 2741
	}
}