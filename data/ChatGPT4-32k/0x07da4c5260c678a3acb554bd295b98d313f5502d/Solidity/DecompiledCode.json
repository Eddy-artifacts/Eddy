{
	"address": "0x07da4c5260c678a3acb554bd295b98d313f5502d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the corresponding Solidity source code from the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    address private _owner;\n    uint256 private _maxTxAmount;\n    uint256 private _maxWalletSize;\n    uint256 private _transferDelayEnabled;\n    uint256 private _taxSwapThreshold;\n    uint256 private _maxTaxSwap;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event MaxTxAmountUpdated(uint256 maxTxAmount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function _SafeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"Subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    function _SafeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Addition overflow\");\n        return c;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"Approve from the zero address\");\n        require(spender != address(0), \"Approve to the zero address\");\n\n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowance[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"Transfer from the zero address\");\n        require(recipient != address(0), \"Transfer to the zero address\");\n\n        _balanceOf[sender] = _SafeSub(_balanceOf[sender], amount);\n        _balanceOf[recipient] = _SafeAdd(_balanceOf[recipient], amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n}\n```\n\nPlease note that this code is a simplified and more readable version of the decompiled code. The actual Solidity code may differ in terms of variable names and additional functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495820,
	"id": "chatcmpl-8VPDwTN8xzam5hOhQMAnM5aKsSD16",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 00:20 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) owner_5; // STORAGE[0x5]\nuint256 __maxTxAmount; // STORAGE[0x7]\nuint256 __maxWalletSize; // STORAGE[0x8]\nuint256 __taxSwapThreshold; // STORAGE[0x9]\nuint256 __maxTaxSwap; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x6] bytes 0 to 0\nuint256 _@_whqp_1171; // STORAGE[0x6] bytes 1 to 20\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @_qrgw_1146(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction @_whqp_1171(uint256 varg0, uint256 varg1, address varg2) private { \n    if (varg2 - _@_whqp_1171) {\n        v0 = _SafeSub('SafeMath:  subtraction overflow', varg0, varg1);\n        return v0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1055(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_704(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction () public payable { \n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1055(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_704(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1055(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        if (_transferDelayEnabled) {\n            v5 = v6 = stor_13_0_19 != address(varg1);\n            if (stor_13_0_19 != address(varg1)) {\n                v5 = v7 = address(owner_14) != address(varg1);\n            }\n            if (v5) {\n                require(block.number > owner_5[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                owner_5[tx.origin] = block.number;\n            }\n        }\n        v8 = v9 = address(owner_14) == address(varg2);\n        if (v9) {\n            v8 = v10 = stor_13_0_19 != address(varg1);\n        }\n        if (v8) {\n            v8 = v11 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v8) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_12 < stor_11) {\n                require(!varg1.code.size);\n            }\n            require(stor_12 + 1, Panic(17)); // arithmetic overflow or underflow\n            stor_12 += 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n            v12 = v13 = 3524;\n            v14 = v15 = 100;\n            v16 = v17 = 8129;\n            if (stor_f < stor_12) {\n                v18 = v19 = stor_d;\n            } else {\n                v18 = v20 = stor_b;\n            }\n        }\n        v21 = v22 = address(owner_14) == address(varg1);\n        if (v22) {\n            v21 = v23 = this != address(varg2);\n        }\n        if (v21) {\n            v21 = v24 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v21) {\n            v25 = v26 = varg0 <= __maxTxAmount;\n            if (!bool(varg0 > __maxTxAmount)) {\n                v25 = v27 = _balanceOf[_@_whqp_1171] < __maxTaxSwap;\n            }\n            require(v25, Error('Exceeds the _maxTxAmount.'));\n            v12 = v28 = 3764;\n            v14 = v29 = 100;\n            v16 = v30 = 8166;\n            if (stor_12 > stor_10) {\n                v18 = v31 = stor_e;\n            } else {\n                v18 = v32 = stor_c;\n            }\n        }\n        if (0 - varg0) {\n            v33 = v18 * varg0;\n            require((v18 == v33 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v33 / varg0 == v18, Error('SafeMath: multiplication overflow'));\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        } else {\n            v33 = v34 = 0;\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        }\n        if (v14) {\n            require(v14, Panic(18)); // division by zero\n            v0 = v33 / v14;\n            // Unknown jump to Block {'0xdc4', '0xeb4'}. Refer to 3-address code (TAC);\n            v35 = v36 = stor_12 > stor_11;\n            if (v36) {\n                v35 = v37 = uint8(owner_4[address(varg2)]);\n            }\n            require(v35);\n        } else {\n            v38 = new bytes[](v39.length);\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                v38[v40] = v39[v40];\n                v40 += 32;\n            }\n            v38[v39.length] = 0;\n            revert(Error(v38));\n        }\n        // Unknown jump to Block 0x11c2. Refer to 3-address code (TAC);\n        v42 = v43 = !uint8(owner_14 >> 168);\n        if (!bool(uint8(owner_14 >> 168))) {\n            v42 = v44 = address(owner_14) == address(varg1);\n        }\n        if (v42) {\n            v42 = v45 = uint8(owner_14 >> 176);\n        }\n        if (v42) {\n            v42 = v46 = _balanceOf[this] > __taxSwapThreshold;\n        }\n        if (v42) {\n            v42 = v47 = stor_12 > stor_11;\n        }\n        if (v42) {\n            v42 = v48 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v42) {\n            v42 = v49 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v42) {\n            v50 = @_qrgw_1146(__maxTaxSwap, _balanceOf[this]);\n            v51 = @_qrgw_1146(v50, varg0);\n            owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (v51) {\n                if (uint8(owner_14 >> 160)) {\n                    v52 = new address[](2);\n                    CALLDATACOPY(v52.data, msg.data.length, 64);\n                    require(0 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v53 = v52.data;\n                    v52[0] = address(this);\n                    v54, /* address */ v55 = stor_13_0_19.WETH().gas(msg.gas);\n                    require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v55 == address(v55));\n                    require(1 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v52[1] = address(v55);\n                    @_approve_704(v51, stor_13_0_19, this);\n                    v56 = new address[](v52.length);\n                    v57 = v58 = v56.data;\n                    v59 = v60 = v52.data;\n                    v61 = v62 = 0;\n                    while (v61 < v52.length) {\n                        MEM[v57] = address(MEM[v59]);\n                        v59 += 32;\n                        v57 += 32;\n                        v61 += 1;\n                    }\n                    require(bool(stor_13_0_19.code.size));\n                    v63 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v51, 0, v56, address(this), block.timestamp, v64, address(this)).gas(msg.gas);\n                    require(bool(v63), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                }\n            }\n            owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (this.balance) {\n                v65 = _@_whqp_1171.call().value(this.balance).gas(!this.balance * 2300);\n                require(bool(v65), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n        }\n    }\n    if (v0) {\n        v66 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v66;\n        emit Transfer(address(varg2), this, v0);\n    }\n    v67 = @_whqp_1171(varg0, _balanceOf[address(varg2)], varg2);\n    _balanceOf[address(varg2)] = v67;\n    v68 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    v69 = _SafeAdd(v68, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v69;\n    v70 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v70;\n    emit Transfer(address(varg2), address(varg1), v70);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x23b872dd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else {\n                require(0x18160ddd == function_selector >> 224);\n                totalSupply();\n            }\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x715018a6 == function_selector >> 224) {\n            renounceOwnership();\n        } else {\n            require(0x751039fc == function_selector >> 224);\n            removeLimits();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 00:20 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) owner_5; // STORAGE[0x5]\nuint256 __maxTxAmount; // STORAGE[0x7]\nuint256 __maxWalletSize; // STORAGE[0x8]\nuint256 __taxSwapThreshold; // STORAGE[0x9]\nuint256 __maxTaxSwap; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x6] bytes 0 to 0\nuint256 _@_whqp_1171; // STORAGE[0x6] bytes 1 to 20\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @_qrgw_1146(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction @_whqp_1171(uint256 varg0, uint256 varg1, address varg2) private { \n    if (varg2 - _@_whqp_1171) {\n        v0 = _SafeSub('SafeMath:  subtraction overflow', varg0, varg1);\n        return v0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1055(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_704(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction () public payable { \n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1055(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_704(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1055(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        if (_transferDelayEnabled) {\n            v5 = v6 = stor_13_0_19 != address(varg1);\n            if (stor_13_0_19 != address(varg1)) {\n                v5 = v7 = address(owner_14) != address(varg1);\n            }\n            if (v5) {\n                require(block.number > owner_5[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                owner_5[tx.origin] = block.number;\n            }\n        }\n        v8 = v9 = address(owner_14) == address(varg2);\n        if (v9) {\n            v8 = v10 = stor_13_0_19 != address(varg1);\n        }\n        if (v8) {\n            v8 = v11 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v8) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_12 < stor_11) {\n                require(!varg1.code.size);\n            }\n            require(stor_12 + 1, Panic(17)); // arithmetic overflow or underflow\n            stor_12 += 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n            v12 = v13 = 3524;\n            v14 = v15 = 100;\n            v16 = v17 = 8129;\n            if (stor_f < stor_12) {\n                v18 = v19 = stor_d;\n            } else {\n                v18 = v20 = stor_b;\n            }\n        }\n        v21 = v22 = address(owner_14) == address(varg1);\n        if (v22) {\n            v21 = v23 = this != address(varg2);\n        }\n        if (v21) {\n            v21 = v24 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v21) {\n            v25 = v26 = varg0 <= __maxTxAmount;\n            if (!bool(varg0 > __maxTxAmount)) {\n                v25 = v27 = _balanceOf[_@_whqp_1171] < __maxTaxSwap;\n            }\n            require(v25, Error('Exceeds the _maxTxAmount.'));\n            v12 = v28 = 3764;\n            v14 = v29 = 100;\n            v16 = v30 = 8166;\n            if (stor_12 > stor_10) {\n                v18 = v31 = stor_e;\n            } else {\n                v18 = v32 = stor_c;\n            }\n        }\n        if (0 - varg0) {\n            v33 = v18 * varg0;\n            require((v18 == v33 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v33 / varg0 == v18, Error('SafeMath: multiplication overflow'));\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        } else {\n            v33 = v34 = 0;\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        }\n        if (v14) {\n            require(v14, Panic(18)); // division by zero\n            v0 = v33 / v14;\n            // Unknown jump to Block {'0xdc4', '0xeb4'}. Refer to 3-address code (TAC);\n            v35 = v36 = stor_12 > stor_11;\n            if (v36) {\n                v35 = v37 = uint8(owner_4[address(varg2)]);\n            }\n            require(v35);\n        } else {\n            v38 = new bytes[](v39.length);\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                v38[v40] = v39[v40];\n                v40 += 32;\n            }\n            v38[v39.length] = 0;\n            revert(Error(v38));\n        }\n        // Unknown jump to Block 0x11c2. Refer to 3-address code (TAC);\n        v42 = v43 = !uint8(owner_14 >> 168);\n        if (!bool(uint8(owner_14 >> 168))) {\n            v42 = v44 = address(owner_14) == address(varg1);\n        }\n        if (v42) {\n            v42 = v45 = uint8(owner_14 >> 176);\n        }\n        if (v42) {\n            v42 = v46 = _balanceOf[this] > __taxSwapThreshold;\n        }\n        if (v42) {\n            v42 = v47 = stor_12 > stor_11;\n        }\n        if (v42) {\n            v42 = v48 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v42) {\n            v42 = v49 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v42) {\n            v50 = @_qrgw_1146(__maxTaxSwap, _balanceOf[this]);\n            v51 = @_qrgw_1146(v50, varg0);\n            owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (v51) {\n                if (uint8(owner_14 >> 160)) {\n                    v52 = new address[](2);\n                    CALLDATACOPY(v52.data, msg.data.length, 64);\n                    require(0 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v53 = v52.data;\n                    v52[0] = address(this);\n                    v54, /* address */ v55 = stor_13_0_19.WETH().gas(msg.gas);\n                    require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v55 == address(v55));\n                    require(1 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v52[1] = address(v55);\n                    @_approve_704(v51, stor_13_0_19, this);\n                    v56 = new address[](v52.length);\n                    v57 = v58 = v56.data;\n                    v59 = v60 = v52.data;\n                    v61 = v62 = 0;\n                    while (v61 < v52.length) {\n                        MEM[v57] = address(MEM[v59]);\n                        v59 += 32;\n                        v57 += 32;\n                        v61 += 1;\n                    }\n                    require(bool(stor_13_0_19.code.size));\n                    v63 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v51, 0, v56, address(this), block.timestamp, v64, address(this)).gas(msg.gas);\n                    require(bool(v63), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                }\n            }\n            owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (this.balance) {\n                v65 = _@_whqp_1171.call().value(this.balance).gas(!this.balance * 2300);\n                require(bool(v65), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n        }\n    }\n    if (v0) {\n        v66 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v66;\n        emit Transfer(address(varg2), this, v0);\n    }\n    v67 = @_whqp_1171(varg0, _balanceOf[address(varg2)], varg2);\n    _balanceOf[address(varg2)] = v67;\n    v68 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    v69 = _SafeAdd(v68, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v69;\n    v70 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v70;\n    emit Transfer(address(varg2), address(varg1), v70);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x23b872dd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else {\n                require(0x18160ddd == function_selector >> 224);\n                totalSupply();\n            }\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x715018a6 == function_selector >> 224) {\n            renounceOwnership();\n        } else {\n            require(0x751039fc == function_selector >> 224);\n            removeLimits();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 00:20 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) owner_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) owner_5; // STORAGE[0x5]\nuint256 __maxTxAmount; // STORAGE[0x7]\nuint256 __maxWalletSize; // STORAGE[0x8]\nuint256 __taxSwapThreshold; // STORAGE[0x9]\nuint256 __maxTaxSwap; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_10; // STORAGE[0x10]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x6] bytes 0 to 0\nuint256 _@_whqp_1171; // STORAGE[0x6] bytes 1 to 20\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @_qrgw_1146(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction @_whqp_1171(uint256 varg0, uint256 varg1, address varg2) private { \n    if (varg2 - _@_whqp_1171) {\n        v0 = _SafeSub('SafeMath:  subtraction overflow', varg0, varg1);\n        return v0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_704(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1055(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_704(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction () public payable { \n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1055(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_704(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_704(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1055(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2), Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != address(varg2);\n    if (_owner != address(varg2)) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        if (_transferDelayEnabled) {\n            v5 = v6 = stor_13_0_19 != address(varg1);\n            if (stor_13_0_19 != address(varg1)) {\n                v5 = v7 = address(owner_14) != address(varg1);\n            }\n            if (v5) {\n                require(block.number > owner_5[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                owner_5[tx.origin] = block.number;\n            }\n        }\n        v8 = v9 = address(owner_14) == address(varg2);\n        if (v9) {\n            v8 = v10 = stor_13_0_19 != address(varg1);\n        }\n        if (v8) {\n            v8 = v11 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v8) {\n            require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n            require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n            require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n            if (stor_12 < stor_11) {\n                require(!varg1.code.size);\n            }\n            require(stor_12 + 1, Panic(17)); // arithmetic overflow or underflow\n            stor_12 += 1;\n            owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n            v12 = v13 = 3524;\n            v14 = v15 = 100;\n            v16 = v17 = 8129;\n            if (stor_f < stor_12) {\n                v18 = v19 = stor_d;\n            } else {\n                v18 = v20 = stor_b;\n            }\n        }\n        v21 = v22 = address(owner_14) == address(varg1);\n        if (v22) {\n            v21 = v23 = this != address(varg2);\n        }\n        if (v21) {\n            v21 = v24 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v21) {\n            v25 = v26 = varg0 <= __maxTxAmount;\n            if (!bool(varg0 > __maxTxAmount)) {\n                v25 = v27 = _balanceOf[_@_whqp_1171] < __maxTaxSwap;\n            }\n            require(v25, Error('Exceeds the _maxTxAmount.'));\n            v12 = v28 = 3764;\n            v14 = v29 = 100;\n            v16 = v30 = 8166;\n            if (stor_12 > stor_10) {\n                v18 = v31 = stor_e;\n            } else {\n                v18 = v32 = stor_c;\n            }\n        }\n        if (0 - varg0) {\n            v33 = v18 * varg0;\n            require((v18 == v33 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n            require(varg0, Panic(18)); // division by zero\n            require(v33 / varg0 == v18, Error('SafeMath: multiplication overflow'));\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        } else {\n            v33 = v34 = 0;\n            // Unknown jump to Block {'0x1fe6', '0x1fc1'}. Refer to 3-address code (TAC);\n        }\n        if (v14) {\n            require(v14, Panic(18)); // division by zero\n            v0 = v33 / v14;\n            // Unknown jump to Block {'0xdc4', '0xeb4'}. Refer to 3-address code (TAC);\n            v35 = v36 = stor_12 > stor_11;\n            if (v36) {\n                v35 = v37 = uint8(owner_4[address(varg2)]);\n            }\n            require(v35);\n        } else {\n            v38 = new bytes[](v39.length);\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                v38[v40] = v39[v40];\n                v40 += 32;\n            }\n            v38[v39.length] = 0;\n            revert(Error(v38));\n        }\n        // Unknown jump to Block 0x11c2. Refer to 3-address code (TAC);\n        v42 = v43 = !uint8(owner_14 >> 168);\n        if (!bool(uint8(owner_14 >> 168))) {\n            v42 = v44 = address(owner_14) == address(varg1);\n        }\n        if (v42) {\n            v42 = v45 = uint8(owner_14 >> 176);\n        }\n        if (v42) {\n            v42 = v46 = _balanceOf[this] > __taxSwapThreshold;\n        }\n        if (v42) {\n            v42 = v47 = stor_12 > stor_11;\n        }\n        if (v42) {\n            v42 = v48 = !uint8(owner_3[address(varg1)]);\n        }\n        if (v42) {\n            v42 = v49 = !uint8(owner_3[address(varg2)]);\n        }\n        if (v42) {\n            v50 = @_qrgw_1146(__maxTaxSwap, _balanceOf[this]);\n            v51 = @_qrgw_1146(v50, varg0);\n            owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (v51) {\n                if (uint8(owner_14 >> 160)) {\n                    v52 = new address[](2);\n                    CALLDATACOPY(v52.data, msg.data.length, 64);\n                    require(0 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v53 = v52.data;\n                    v52[0] = address(this);\n                    v54, /* address */ v55 = stor_13_0_19.WETH().gas(msg.gas);\n                    require(bool(v54), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                    require(v55 == address(v55));\n                    require(1 < v52.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                    v52[1] = address(v55);\n                    @_approve_704(v51, stor_13_0_19, this);\n                    v56 = new address[](v52.length);\n                    v57 = v58 = v56.data;\n                    v59 = v60 = v52.data;\n                    v61 = v62 = 0;\n                    while (v61 < v52.length) {\n                        MEM[v57] = address(MEM[v59]);\n                        v59 += 32;\n                        v57 += 32;\n                        v61 += 1;\n                    }\n                    require(bool(stor_13_0_19.code.size));\n                    v63 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v51, 0, v56, address(this), block.timestamp, v64, address(this)).gas(msg.gas);\n                    require(bool(v63), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                }\n            }\n            owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n            if (this.balance) {\n                v65 = _@_whqp_1171.call().value(this.balance).gas(!this.balance * 2300);\n                require(bool(v65), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            }\n        }\n    }\n    if (v0) {\n        v66 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v66;\n        emit Transfer(address(varg2), this, v0);\n    }\n    v67 = @_whqp_1171(varg0, _balanceOf[address(varg2)], varg2);\n    _balanceOf[address(varg2)] = v67;\n    v68 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    v69 = _SafeAdd(v68, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v69;\n    v70 = _SafeSub('SafeMath:  subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v70;\n    emit Transfer(address(varg2), address(varg1), v70);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x23b872dd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else {\n                require(0x18160ddd == function_selector >> 224);\n                totalSupply();\n            }\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0x715018a6 == function_selector >> 224) {\n            renounceOwnership();\n        } else {\n            require(0x751039fc == function_selector >> 224);\n            removeLimits();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 46.079312324523926,
	"usage": {
		"completion_tokens": 747,
		"prompt_tokens": 5793,
		"total_tokens": 6540
	}
}