{
	"address": "0x449335a73eaa9456a47494cfbf2b27588febf3ae",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the provided decompiled code, the Solidity smart contract could look like this:\n\n```solidity\npragma solidity ^0.7.6;\n\ncontract AutomobileCoin {\n    uint256 private _totalSupply;\n    uint256 private _rate;\n    uint256 private _totalFundingSupply;\n    uint256 private _maxSupply;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    address private _owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        _totalSupply = 0;\n        _rate = 0;\n        _maxSupply = 0;\n    }\n\n    function name() public pure returns(string memory) {\n        return \"Automobilecoin\";\n    }\n\n    function approve(address spender, uint256 value) public returns(bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns(uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns(bool) {\n        require(to != address(0));\n        require(value <= _allowances[from][msg.sender]);\n        _balances[from] -= value;\n        _balances[to] += value;\n        _allowances[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function rate() public view returns(uint256) {\n        return _rate;\n    }\n\n    function decimals() public pure returns(uint8) {\n        return 18;\n    }\n\n    function maxSupply() public view returns(uint256) {\n        return _maxSupply;\n    }\n\n    function setRate(uint256 newRate) public {\n        require(msg.sender == _owner);\n        _rate = newRate;\n    }\n\n    function version() public pure returns(string memory) {\n        return \"1.0\";\n    }\n\n    function balanceOf(address account) public view returns(uint256) {\n        return _balances[account];\n    }\n\n    function withdrawCoinToOwner(uint256 value) public {\n        require(msg.sender == _owner);\n        _transferCoins(value, msg.sender);\n    }\n\n    function etherProceeds() public {\n        require(msg.sender == _owner);\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns(string memory) {\n        return \"AUB\";\n    }\n\n    function transfer(address to, uint256 value) public returns(bool) {\n        require(to != address(0));\n        require(value <= _balances[msg.sender]);\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function totalFundingSupply() public view returns(uint256) {\n        return _totalFundingSupply;\n    }\n\n    function allowance(address owner, address spender) public view returns(uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function _transferCoins(uint256 value, address to) private {\n        uint256 amount = value * _rate;\n        require(_totalSupply + amount <= _maxSupply);\n        _balances[to] += amount;\n        _totalSupply += amount;\n        emit Transfer(address(0), to, amount);\n    }\n\n    receive() external payable {\n        _transferCoins(msg.value, msg.sender);\n        _totalFundingSupply += msg.value;\n    }\n}\n```\n\nPlease note that function names like `0x686` and `0x793` were replaced with a more descriptive name `_transferCoins`. It's important to note that the original contract could have additional features or nuances which are not captured in the decompiled code. Always ensure to understand the functionality of the contract thoroughly before deploying or using it. Also note that this contract lacks of SafeMath operations for preventing underflows and overflows.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469674,
	"id": "chatcmpl-8R6HCaalti0fSmqSypMF9gvBRs7Jv",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.36773920059204,
	"usage": {
		"completion_tokens": 916,
		"prompt_tokens": 1992,
		"total_tokens": 2908
	}
}