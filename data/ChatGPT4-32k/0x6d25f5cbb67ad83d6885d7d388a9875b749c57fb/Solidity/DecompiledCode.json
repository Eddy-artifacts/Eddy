{
	"address": "0x6d25f5cbb67ad83d6885d7d388a9875b749c57fb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "It seems like you are requesting a Solidity contract code based on decompiled EVM Bytecode. However, this bytecode is quite complex and seems to involve a number of different function calls depending on the provided function selector. As such, it might not be possible to provide an accurate and complete Solidity contract code that matches exactly with this bytecode. \n\nHowever, I can provide a simple example of what a Solidity contract that includes some of these elements might look like:\n\n```Solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MyContract {\n    mapping(bytes4 => uint256) public function_selector;\n    mapping(address => uint256) public balanceOf;\n    address public owner;\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n    event Mutable_IPFS_SHA3_256(address indexed _owner, bytes _data, uint256 _value);\n    \n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Approval(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[msg.sender]);\n        function_selector[bytes4(keccak256(abi.encodePacked(_spender)))] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    // Other functions go here...\n\n}\n```\n\nPlease note again that this is a simplified and incomplete example and it might not cover all the functionalities of the decompiled bytecode. The decompiled bytecode seems quite complex and appears to be related to a token contract, possibly an ERC721 or ERC20 token. The actual contract could be much more complex with more functions and logic.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485694,
	"id": "chatcmpl-8RARaEIdFnlvzVNLy3ZrINjDPIwxR",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.27 03:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] ___function_selector__; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256 owner; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\n\n// Events\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\nMutable_IPFS_SHA3_256(address, bytes, uint256);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { \n    if (msg.data.length >= 4) {\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0xf1753550) {\n            if (function_selector != 0x70a08231) {\n                if (function_selector != 0x6352211e) {\n                    if (function_selector != 0x81812fc) {\n                        if (function_selector != 0x3bd18a3b) {\n                            if (function_selector != 0xb77cfd0d) {\n                                if (function_selector != 0x8499ecd6) {\n                                    if (function_selector != 0xe985e9c5) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x42842e0e) {\n                                                if (function_selector != 0xb88d4fde) {\n                                                    if (function_selector != 0x95ea7b3) {\n                                                        if (function_selector != 0xa22cb465) {\n                                                            if (function_selector != 0x42966c68) {\n                                                                if (function_selector != 0x1117b0d) {\n                                                                    if (function_selector != 0x22733337) {\n                                                                        if (function_selector == 0xbc04f0af) {\n                                                                            require(!msg.value);\n                                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                            require(msg.sender == owner);\n                                                                            require(varg2 >= 20);\n                                                                            require(varg2 >= varg2 / 20);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v0 = owner.transfer(stor_a, varg2 / 20).gas(msg.gas);\n                                                                            require(v0);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v1 = owner.burn(varg2 / 20).gas(msg.gas);\n                                                                            require(v1);\n                                                                            require(MEM[576]);\n                                                                            STORAGE[keccak256(4, stor_b)] = varg2 - varg2 / 20;\n                                                                            while (352 < 736) {\n                                                                            }\n                                                                            MEM[768] = 0xff5ce378;\n                                                                            require(!STORAGE[keccak256(0, stor_b)]);\n                                                                            STORAGE[keccak256(0, stor_b)] = varg1;\n                                                                            require(STORAGE[keccak256(6, varg1)] + 1 >= STORAGE[keccak256(6, varg1)]);\n                                                                            STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + 1;\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        require(varg1.length <= 64);\n                                                                        require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                        require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                        while (0 > MEM[320] + 32) {\n                                                                            array_3[0] = MEM[320];\n                                                                            MEM[288] = 1;\n                                                                            if (3 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        v2 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, 32, v3, 32);\n                                                                        require(v2);\n                                                                        CALLDATACOPY(704 + MEM[672], msg.data.length, MEM[672] + 31 - (MEM[672] - 1) % 32 - MEM[672]);\n                                                                        emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                        exit;\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    require(varg1.length <= 64);\n                                                                    require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                    require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                    while (0 > STORAGE[keccak256(keccak256(3, varg2))] + 32) {\n                                                                        MEM[704] = array_3[0];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    require(keccak256(MEM[736 len (STORAGE[keccak256(keccak256(3, varg2))])]) == keccak256(MEM[672 len 0]));\n                                                                    require(!STORAGE[keccak256(5, keccak256(MEM[352 len (MEM[320])]))]);\n                                                                    while (0 > MEM[320] + 32) {\n                                                                        array_3[0] = MEM[320];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    v4 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, v3, v3, 0, v3, v3, v3, v3, v3, 32, v3, 32);\n                                                                    require(v4);\n                                                                    CALLDATACOPY(960 + MEM[928], msg.data.length, MEM[928] + 31 - (MEM[928] - 1) % 32 - MEM[928]);\n                                                                    emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                    exit;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                MEM[320] = 0x4cdc9549;\n                                                                v5 = v6 = 3302;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                            require(varg2 < 2);\n                                                            require(varg1 ^ msg.sender);\n                                                            STORAGE[keccak256(keccak256(7, msg.sender), varg1)] = varg2;\n                                                            emit ApprovalForAll(msg.sender, varg1, varg2);\n                                                            exit;\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                        require(STORAGE[keccak256(0, varg2)] ^ 0x0);\n                                                        require(varg1 ^ STORAGE[keccak256(0, varg2)]);\n                                                        require((STORAGE[keccak256(0, varg2)] == msg.sender) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, varg2)]), msg.sender)]);\n                                                        STORAGE[keccak256(1, varg2)] = varg1;\n                                                        emit Approval(STORAGE[keccak256(0, varg2)], varg1, varg2);\n                                                        exit;\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4 + varg4, 1056);\n                                                    require(varg4.length <= 1024);\n                                                    CALLDATACOPY(320, 4 + varg4, 1088);\n                                                }\n                                            } else {\n                                                v7 = dataCopy();\n                                                require(v7);\n                                            }\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            while (352 < 1472) {\n                                            }\n                                            MEM[1504] = 0x92863fe;\n                                            v8 = v9 = 2599;\n                                        } else {\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            MEM[320] = 0x92863fe;\n                                            v8 = v10 = 2312;\n                                        }\n                                        MEM[512] = 0x4cdc9549;\n                                        v5 = v11 = 1692;\n                                        v12 = (STORAGE[keccak256(0, v13)] == v14) | (v14 == STORAGE[keccak256(1, v13)]) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, v13)]), v14)];\n                                    } else {\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                        return STORAGE[keccak256(keccak256(7, varg1), varg2)];\n                                    }\n                                } else {\n                                    require(!msg.value);\n                                    require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                    while (0 > STORAGE[keccak256(keccak256(3, varg1))] + 32) {\n                                        MEM[416] = array_3[0];\n                                        MEM[288] = 1;\n                                        if (3 != 1) {\n                                            break;\n                                        }\n                                    }\n                                    CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                    return 32;\n                                }\n                            } else {\n                                require(!msg.value);\n                                require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                while (0 > STORAGE[keccak256(keccak256(2, varg1))] + 32) {\n                                    MEM[416] = ___function_selector__[0];\n                                    MEM[288] = 1;\n                                    if (3 != 1) {\n                                        break;\n                                    }\n                                }\n                                CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                return 32;\n                            }\n                        } else {\n                            require(!msg.value);\n                            require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                            return STORAGE[keccak256(4, varg1)];\n                        }\n                    } else {\n                        require(!msg.value);\n                        require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                        return STORAGE[keccak256(1, varg1)];\n                    }\n                } else {\n                    require(!msg.value);\n                    require(STORAGE[keccak256(0, varg1)] ^ 0x0);\n                    return STORAGE[keccak256(0, varg1)];\n                }\n            } else {\n                require(!msg.value);\n                require(varg1 < 0x10000000000000000000000000000000000000000);\n                require(varg1 ^ 0x0);\n                return STORAGE[keccak256(6, varg1)];\n            }\n        } else {\n            require(!msg.value);\n            return STORAGE[keccak256(8, varg1)];\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.27 03:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] ___function_selector__; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256 owner; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\n\n// Events\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\nMutable_IPFS_SHA3_256(address, bytes, uint256);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { \n    if (msg.data.length >= 4) {\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0xf1753550) {\n            if (function_selector != 0x70a08231) {\n                if (function_selector != 0x6352211e) {\n                    if (function_selector != 0x81812fc) {\n                        if (function_selector != 0x3bd18a3b) {\n                            if (function_selector != 0xb77cfd0d) {\n                                if (function_selector != 0x8499ecd6) {\n                                    if (function_selector != 0xe985e9c5) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x42842e0e) {\n                                                if (function_selector != 0xb88d4fde) {\n                                                    if (function_selector != 0x95ea7b3) {\n                                                        if (function_selector != 0xa22cb465) {\n                                                            if (function_selector != 0x42966c68) {\n                                                                if (function_selector != 0x1117b0d) {\n                                                                    if (function_selector != 0x22733337) {\n                                                                        if (function_selector == 0xbc04f0af) {\n                                                                            require(!msg.value);\n                                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                            require(msg.sender == owner);\n                                                                            require(varg2 >= 20);\n                                                                            require(varg2 >= varg2 / 20);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v0 = owner.transfer(stor_a, varg2 / 20).gas(msg.gas);\n                                                                            require(v0);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v1 = owner.burn(varg2 / 20).gas(msg.gas);\n                                                                            require(v1);\n                                                                            require(MEM[576]);\n                                                                            STORAGE[keccak256(4, stor_b)] = varg2 - varg2 / 20;\n                                                                            while (352 < 736) {\n                                                                            }\n                                                                            MEM[768] = 0xff5ce378;\n                                                                            require(!STORAGE[keccak256(0, stor_b)]);\n                                                                            STORAGE[keccak256(0, stor_b)] = varg1;\n                                                                            require(STORAGE[keccak256(6, varg1)] + 1 >= STORAGE[keccak256(6, varg1)]);\n                                                                            STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + 1;\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        require(varg1.length <= 64);\n                                                                        require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                        require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                        while (0 > MEM[320] + 32) {\n                                                                            array_3[0] = MEM[320];\n                                                                            MEM[288] = 1;\n                                                                            if (3 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        v2 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, 32, v3, 32);\n                                                                        require(v2);\n                                                                        CALLDATACOPY(704 + MEM[672], msg.data.length, MEM[672] + 31 - (MEM[672] - 1) % 32 - MEM[672]);\n                                                                        emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                        exit;\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    require(varg1.length <= 64);\n                                                                    require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                    require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                    while (0 > STORAGE[keccak256(keccak256(3, varg2))] + 32) {\n                                                                        MEM[704] = array_3[0];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    require(keccak256(MEM[736 len (STORAGE[keccak256(keccak256(3, varg2))])]) == keccak256(MEM[672 len 0]));\n                                                                    require(!STORAGE[keccak256(5, keccak256(MEM[352 len (MEM[320])]))]);\n                                                                    while (0 > MEM[320] + 32) {\n                                                                        array_3[0] = MEM[320];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    v4 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, v3, v3, 0, v3, v3, v3, v3, v3, 32, v3, 32);\n                                                                    require(v4);\n                                                                    CALLDATACOPY(960 + MEM[928], msg.data.length, MEM[928] + 31 - (MEM[928] - 1) % 32 - MEM[928]);\n                                                                    emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                    exit;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                MEM[320] = 0x4cdc9549;\n                                                                v5 = v6 = 3302;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                            require(varg2 < 2);\n                                                            require(varg1 ^ msg.sender);\n                                                            STORAGE[keccak256(keccak256(7, msg.sender), varg1)] = varg2;\n                                                            emit ApprovalForAll(msg.sender, varg1, varg2);\n                                                            exit;\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                        require(STORAGE[keccak256(0, varg2)] ^ 0x0);\n                                                        require(varg1 ^ STORAGE[keccak256(0, varg2)]);\n                                                        require((STORAGE[keccak256(0, varg2)] == msg.sender) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, varg2)]), msg.sender)]);\n                                                        STORAGE[keccak256(1, varg2)] = varg1;\n                                                        emit Approval(STORAGE[keccak256(0, varg2)], varg1, varg2);\n                                                        exit;\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4 + varg4, 1056);\n                                                    require(varg4.length <= 1024);\n                                                    CALLDATACOPY(320, 4 + varg4, 1088);\n                                                }\n                                            } else {\n                                                v7 = dataCopy();\n                                                require(v7);\n                                            }\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            while (352 < 1472) {\n                                            }\n                                            MEM[1504] = 0x92863fe;\n                                            v8 = v9 = 2599;\n                                        } else {\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            MEM[320] = 0x92863fe;\n                                            v8 = v10 = 2312;\n                                        }\n                                        MEM[512] = 0x4cdc9549;\n                                        v5 = v11 = 1692;\n                                        v12 = (STORAGE[keccak256(0, v13)] == v14) | (v14 == STORAGE[keccak256(1, v13)]) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, v13)]), v14)];\n                                    } else {\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                        return STORAGE[keccak256(keccak256(7, varg1), varg2)];\n                                    }\n                                } else {\n                                    require(!msg.value);\n                                    require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                    while (0 > STORAGE[keccak256(keccak256(3, varg1))] + 32) {\n                                        MEM[416] = array_3[0];\n                                        MEM[288] = 1;\n                                        if (3 != 1) {\n                                            break;\n                                        }\n                                    }\n                                    CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                    return 32;\n                                }\n                            } else {\n                                require(!msg.value);\n                                require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                while (0 > STORAGE[keccak256(keccak256(2, varg1))] + 32) {\n                                    MEM[416] = ___function_selector__[0];\n                                    MEM[288] = 1;\n                                    if (3 != 1) {\n                                        break;\n                                    }\n                                }\n                                CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                return 32;\n                            }\n                        } else {\n                            require(!msg.value);\n                            require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                            return STORAGE[keccak256(4, varg1)];\n                        }\n                    } else {\n                        require(!msg.value);\n                        require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                        return STORAGE[keccak256(1, varg1)];\n                    }\n                } else {\n                    require(!msg.value);\n                    require(STORAGE[keccak256(0, varg1)] ^ 0x0);\n                    return STORAGE[keccak256(0, varg1)];\n                }\n            } else {\n                require(!msg.value);\n                require(varg1 < 0x10000000000000000000000000000000000000000);\n                require(varg1 ^ 0x0);\n                return STORAGE[keccak256(6, varg1)];\n            }\n        } else {\n            require(!msg.value);\n            return STORAGE[keccak256(8, varg1)];\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.27 03:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] ___function_selector__; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256 owner; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\n\n// Events\nApproval(address, address, uint256);\nApprovalForAll(address, address, bool);\nMutable_IPFS_SHA3_256(address, bytes, uint256);\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public payable { \n    if (msg.data.length >= 4) {\n        MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (function_selector != 0xf1753550) {\n            if (function_selector != 0x70a08231) {\n                if (function_selector != 0x6352211e) {\n                    if (function_selector != 0x81812fc) {\n                        if (function_selector != 0x3bd18a3b) {\n                            if (function_selector != 0xb77cfd0d) {\n                                if (function_selector != 0x8499ecd6) {\n                                    if (function_selector != 0xe985e9c5) {\n                                        if (function_selector != 0x23b872dd) {\n                                            if (function_selector != 0x42842e0e) {\n                                                if (function_selector != 0xb88d4fde) {\n                                                    if (function_selector != 0x95ea7b3) {\n                                                        if (function_selector != 0xa22cb465) {\n                                                            if (function_selector != 0x42966c68) {\n                                                                if (function_selector != 0x1117b0d) {\n                                                                    if (function_selector != 0x22733337) {\n                                                                        if (function_selector == 0xbc04f0af) {\n                                                                            require(!msg.value);\n                                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                                            require(msg.sender == owner);\n                                                                            require(varg2 >= 20);\n                                                                            require(varg2 >= varg2 / 20);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v0 = owner.transfer(stor_a, varg2 / 20).gas(msg.gas);\n                                                                            require(v0);\n                                                                            require(owner.code.size);\n                                                                            require(this ^ owner);\n                                                                            v1 = owner.burn(varg2 / 20).gas(msg.gas);\n                                                                            require(v1);\n                                                                            require(MEM[576]);\n                                                                            STORAGE[keccak256(4, stor_b)] = varg2 - varg2 / 20;\n                                                                            while (352 < 736) {\n                                                                            }\n                                                                            MEM[768] = 0xff5ce378;\n                                                                            require(!STORAGE[keccak256(0, stor_b)]);\n                                                                            STORAGE[keccak256(0, stor_b)] = varg1;\n                                                                            require(STORAGE[keccak256(6, varg1)] + 1 >= STORAGE[keccak256(6, varg1)]);\n                                                                            STORAGE[keccak256(6, varg1)] = STORAGE[keccak256(6, varg1)] + 1;\n                                                                        }\n                                                                    } else {\n                                                                        require(!msg.value);\n                                                                        require(varg1.length <= 64);\n                                                                        require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                        require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                        while (0 > MEM[320] + 32) {\n                                                                            array_3[0] = MEM[320];\n                                                                            MEM[288] = 1;\n                                                                            if (3 != 1) {\n                                                                                break;\n                                                                            }\n                                                                        }\n                                                                        v2 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, 32, v3, 32);\n                                                                        require(v2);\n                                                                        CALLDATACOPY(704 + MEM[672], msg.data.length, MEM[672] + 31 - (MEM[672] - 1) % 32 - MEM[672]);\n                                                                        emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                        exit;\n                                                                    }\n                                                                } else {\n                                                                    require(!msg.value);\n                                                                    require(varg1.length <= 64);\n                                                                    require(STORAGE[keccak256(0, varg2)] == msg.sender);\n                                                                    require(keccak256(MEM[0x160 len (MEM[0x140])]) ^ keccak256(MEM[0x220 len 0x0]));\n                                                                    while (0 > STORAGE[keccak256(keccak256(3, varg2))] + 32) {\n                                                                        MEM[704] = array_3[0];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    require(keccak256(MEM[736 len (STORAGE[keccak256(keccak256(3, varg2))])]) == keccak256(MEM[672 len 0]));\n                                                                    require(!STORAGE[keccak256(5, keccak256(MEM[352 len (MEM[320])]))]);\n                                                                    while (0 > MEM[320] + 32) {\n                                                                        array_3[0] = MEM[320];\n                                                                        MEM[288] = 1;\n                                                                        if (3 != 1) {\n                                                                            break;\n                                                                        }\n                                                                    }\n                                                                    v4 = dataCopy(v3, v3, v3, v3, v3, v3, 0, v3, v3, v3, 0, v3, v3, v3, v3, v3, 32, v3, 32);\n                                                                    require(v4);\n                                                                    CALLDATACOPY(960 + MEM[928], msg.data.length, MEM[928] + 31 - (MEM[928] - 1) % 32 - MEM[928]);\n                                                                    emit Mutable_IPFS_SHA3_256(msg.sender, varg2);\n                                                                    exit;\n                                                                }\n                                                            } else {\n                                                                require(!msg.value);\n                                                                MEM[320] = 0x4cdc9549;\n                                                                v5 = v6 = 3302;\n                                                            }\n                                                        } else {\n                                                            require(!msg.value);\n                                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                            require(varg2 < 2);\n                                                            require(varg1 ^ msg.sender);\n                                                            STORAGE[keccak256(keccak256(7, msg.sender), varg1)] = varg2;\n                                                            emit ApprovalForAll(msg.sender, varg1, varg2);\n                                                            exit;\n                                                        }\n                                                    } else {\n                                                        require(!msg.value);\n                                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                                        require(STORAGE[keccak256(0, varg2)] ^ 0x0);\n                                                        require(varg1 ^ STORAGE[keccak256(0, varg2)]);\n                                                        require((STORAGE[keccak256(0, varg2)] == msg.sender) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, varg2)]), msg.sender)]);\n                                                        STORAGE[keccak256(1, varg2)] = varg1;\n                                                        emit Approval(STORAGE[keccak256(0, varg2)], varg1, varg2);\n                                                        exit;\n                                                    }\n                                                } else {\n                                                    CALLDATACOPY(320, 4 + varg4, 1056);\n                                                    require(varg4.length <= 1024);\n                                                    CALLDATACOPY(320, 4 + varg4, 1088);\n                                                }\n                                            } else {\n                                                v7 = dataCopy();\n                                                require(v7);\n                                            }\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            while (352 < 1472) {\n                                            }\n                                            MEM[1504] = 0x92863fe;\n                                            v8 = v9 = 2599;\n                                        } else {\n                                            require(!msg.value);\n                                            require(varg1 < 0x10000000000000000000000000000000000000000);\n                                            require(varg2 < 0x10000000000000000000000000000000000000000);\n                                            MEM[320] = 0x92863fe;\n                                            v8 = v10 = 2312;\n                                        }\n                                        MEM[512] = 0x4cdc9549;\n                                        v5 = v11 = 1692;\n                                        v12 = (STORAGE[keccak256(0, v13)] == v14) | (v14 == STORAGE[keccak256(1, v13)]) | STORAGE[keccak256(keccak256(0x7, STORAGE[keccak256(0, v13)]), v14)];\n                                    } else {\n                                        require(!msg.value);\n                                        require(varg1 < 0x10000000000000000000000000000000000000000);\n                                        require(varg2 < 0x10000000000000000000000000000000000000000);\n                                        return STORAGE[keccak256(keccak256(7, varg1), varg2)];\n                                    }\n                                } else {\n                                    require(!msg.value);\n                                    require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                    while (0 > STORAGE[keccak256(keccak256(3, varg1))] + 32) {\n                                        MEM[416] = array_3[0];\n                                        MEM[288] = 1;\n                                        if (3 != 1) {\n                                            break;\n                                        }\n                                    }\n                                    CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                    return 32;\n                                }\n                            } else {\n                                require(!msg.value);\n                                require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                                while (0 > STORAGE[keccak256(keccak256(2, varg1))] + 32) {\n                                    MEM[416] = ___function_selector__[0];\n                                    MEM[288] = 1;\n                                    if (3 != 1) {\n                                        break;\n                                    }\n                                }\n                                CALLDATACOPY(448 + MEM[416], msg.data.length, MEM[416] + 31 - (MEM[416] - 1) % 32 - MEM[416]);\n                                return 32;\n                            }\n                        } else {\n                            require(!msg.value);\n                            require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                            return STORAGE[keccak256(4, varg1)];\n                        }\n                    } else {\n                        require(!msg.value);\n                        require(STORAGE[keccak256(0x0, varg1)] ^ 0x0);\n                        return STORAGE[keccak256(1, varg1)];\n                    }\n                } else {\n                    require(!msg.value);\n                    require(STORAGE[keccak256(0, varg1)] ^ 0x0);\n                    return STORAGE[keccak256(0, varg1)];\n                }\n            } else {\n                require(!msg.value);\n                require(varg1 < 0x10000000000000000000000000000000000000000);\n                require(varg1 ^ 0x0);\n                return STORAGE[keccak256(6, varg1)];\n            }\n        } else {\n            require(!msg.value);\n            return STORAGE[keccak256(8, varg1)];\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 16.781712532043457,
	"usage": {
		"completion_tokens": 439,
		"prompt_tokens": 2758,
		"total_tokens": 3197
	}
}