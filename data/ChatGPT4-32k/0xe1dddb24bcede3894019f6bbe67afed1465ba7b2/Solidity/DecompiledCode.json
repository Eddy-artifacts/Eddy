{
	"address": "0xe1dddb24bcede3894019f6bbe67afed1465ba7b2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code for the given decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _userDepositedWei;\n    mapping (address => uint256) private _userWithdrewWei;\n    mapping (address => uint256) private _userReferralsWei;\n    mapping (address => uint256) private _userDividendsWei;\n    uint256 private _totalDepositedWei;\n    uint256 private _totalWithdrewWei;\n    uint256 private _investorNum;\n    address private _owner;\n    address private _partner;\n\n    event Invest(address indexed investor, uint256 amount);\n\n    constructor(address owner) {\n        _owner = owner;\n    }\n\n    function userDividendsWei(address user) public view returns (uint256) {\n        return 7 * _userDividendsWei[user] / 100 * (block.number - _userDividendsWei[user]) / 5900;\n    }\n\n    function investorNum() public view returns (uint256) {\n        return _investorNum;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function setPartner(address partner) public {\n        require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n        _partner = partner;\n    }\n\n    function totalWithdrewWei() public view returns (uint256) {\n        return _totalWithdrewWei;\n    }\n\n    function partner() public view returns (address) {\n        return _partner;\n    }\n\n    function userDepositedWei(address user) public view returns (uint256) {\n        return _userDepositedWei[user];\n    }\n\n    function reFund(address user, uint256 amount) public {\n        require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n        payable(user).transfer(amount);\n        _userDepositedWei[user] = 0;\n    }\n\n    function totalDepositedWei() public view returns (uint256) {\n        return _totalDepositedWei;\n    }\n\n    function userReferralsWei(address user) public view returns (uint256) {\n        return _userReferralsWei[user];\n    }\n\n    function userWithdrewWei(address user) public view returns (uint256) {\n        return _userWithdrewWei[user];\n    }\n\n    fallback() external payable {\n        emit Invest(msg.sender, msg.value);\n        payable(_owner).transfer(msg.value / 10);\n        payable(_partner).transfer(msg.value / 20);\n\n        if (_userDepositedWei[msg.sender] > 0) {\n            uint256 dividends = _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n            payable(msg.sender).transfer(dividends);\n            _userWithdrewWei[msg.sender] += dividends;\n            _totalWithdrewWei += dividends;\n            _investorNum += 1;\n        }\n\n        _userDividendsWei[msg.sender] = block.number;\n        _userDividendsWei[msg.sender] += msg.value;\n        _totalDepositedWei += msg.value;\n    }\n}\n```\n\nPlease note that this smart contract is just a representation of the decompiled code. It may not be perfect, or it may not work as you expect due to the lack of the original code context. Always test the contract thoroughly before deploying it to the main network.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470386,
	"id": "chatcmpl-8R6SgTkvacAPN2tArd9aACfeK95mf",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 09:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x5]\nuint256 _totalDepositedWei; // STORAGE[0x6]\nuint256 _totalWithdrewWei; // STORAGE[0x7]\nuint256 _investorNum; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _partner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\ninvest(address, uint256);\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    return 7 * _userDividendsWei[varg0] / 100 * (block.number - _userDividendsWei[varg0]) / 5900;\n}\n\nfunction investorNum() public nonPayable { \n    return _investorNum;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPartner(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    _partner = varg0;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction partner() public nonPayable { \n    return _partner;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction reFund(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    _userDepositedWei[varg0] = 0;\n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction fallback() public payable { \n    emit invest(msg.sender, msg.value);\n    v0 = _owner.call().value(msg.value / 10).gas(!(msg.value / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _partner.call().value(msg.value / 20).gas(2300 * !(msg.value / 20));\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] > 0) {\n        v2 = msg.sender.call().value(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900).gas(2300 * !(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900));\n        require(v2); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _totalWithdrewWei += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _investorNum += 1;\n    }\n    v3 = new bytes[](msg.data.length);\n    CALLDATACOPY(v3.data, 0, msg.data.length);\n    v4 = v5 = address(MEM[20 + v3]) > 0;\n    if (v5) {\n        v4 = v6 = msg.sender != address(MEM[20 + v3]);\n    }\n    if (v4) {\n        v7 = address(MEM[20 + v3]).call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v7); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[20 + v3])] += msg.value / 10;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] += msg.value;\n    _totalDepositedWei += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1b68adff) {\n            userDividendsWei(address);\n        } else if (0x544b255a == function_selector) {\n            investorNum();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa16d5960 == function_selector) {\n            setPartner(address);\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xbe10862b == function_selector) {\n            partner();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xe557498b == function_selector) {\n            reFund(address,uint256);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 09:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x5]\nuint256 _totalDepositedWei; // STORAGE[0x6]\nuint256 _totalWithdrewWei; // STORAGE[0x7]\nuint256 _investorNum; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _partner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\ninvest(address, uint256);\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    return 7 * _userDividendsWei[varg0] / 100 * (block.number - _userDividendsWei[varg0]) / 5900;\n}\n\nfunction investorNum() public nonPayable { \n    return _investorNum;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPartner(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    _partner = varg0;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction partner() public nonPayable { \n    return _partner;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction reFund(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    _userDepositedWei[varg0] = 0;\n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction fallback() public payable { \n    emit invest(msg.sender, msg.value);\n    v0 = _owner.call().value(msg.value / 10).gas(!(msg.value / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _partner.call().value(msg.value / 20).gas(2300 * !(msg.value / 20));\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] > 0) {\n        v2 = msg.sender.call().value(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900).gas(2300 * !(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900));\n        require(v2); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _totalWithdrewWei += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _investorNum += 1;\n    }\n    v3 = new bytes[](msg.data.length);\n    CALLDATACOPY(v3.data, 0, msg.data.length);\n    v4 = v5 = address(MEM[20 + v3]) > 0;\n    if (v5) {\n        v4 = v6 = msg.sender != address(MEM[20 + v3]);\n    }\n    if (v4) {\n        v7 = address(MEM[20 + v3]).call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v7); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[20 + v3])] += msg.value / 10;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] += msg.value;\n    _totalDepositedWei += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1b68adff) {\n            userDividendsWei(address);\n        } else if (0x544b255a == function_selector) {\n            investorNum();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa16d5960 == function_selector) {\n            setPartner(address);\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xbe10862b == function_selector) {\n            partner();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xe557498b == function_selector) {\n            reFund(address,uint256);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 09:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x5]\nuint256 _totalDepositedWei; // STORAGE[0x6]\nuint256 _totalWithdrewWei; // STORAGE[0x7]\nuint256 _investorNum; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _partner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\ninvest(address, uint256);\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    return 7 * _userDividendsWei[varg0] / 100 * (block.number - _userDividendsWei[varg0]) / 5900;\n}\n\nfunction investorNum() public nonPayable { \n    return _investorNum;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPartner(address varg0) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    _partner = varg0;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction partner() public nonPayable { \n    return _partner;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction reFund(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner, 'OnlyOwner methods called by non-owner.');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    _userDepositedWei[varg0] = 0;\n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction fallback() public payable { \n    emit invest(msg.sender, msg.value);\n    v0 = _owner.call().value(msg.value / 10).gas(!(msg.value / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = _partner.call().value(msg.value / 20).gas(2300 * !(msg.value / 20));\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] > 0) {\n        v2 = msg.sender.call().value(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900).gas(2300 * !(_userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900));\n        require(v2); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _totalWithdrewWei += _userDividendsWei[msg.sender] * 7 / 100 * (block.number - _userDividendsWei[msg.sender]) / 5900;\n        _investorNum += 1;\n    }\n    v3 = new bytes[](msg.data.length);\n    CALLDATACOPY(v3.data, 0, msg.data.length);\n    v4 = v5 = address(MEM[20 + v3]) > 0;\n    if (v5) {\n        v4 = v6 = msg.sender != address(MEM[20 + v3]);\n    }\n    if (v4) {\n        v7 = address(MEM[20 + v3]).call().value(msg.value / 10).gas(2300 * !(msg.value / 10));\n        require(v7); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[20 + v3])] += msg.value / 10;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] += msg.value;\n    _totalDepositedWei += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1b68adff) {\n            userDividendsWei(address);\n        } else if (0x544b255a == function_selector) {\n            investorNum();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa16d5960 == function_selector) {\n            setPartner(address);\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xbe10862b == function_selector) {\n            partner();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xe557498b == function_selector) {\n            reFund(address,uint256);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 52.29695105552673,
	"usage": {
		"completion_tokens": 736,
		"prompt_tokens": 1487,
		"total_tokens": 2223
	}
}