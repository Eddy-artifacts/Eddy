{
	"address": "0xbc3d0e2cf6720665c49455391b239160c89cdaa1",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity smart contract equivalent of your decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _invested;\n    mapping (address => uint256) private _payments;\n    mapping (address => uint256) private _investedRef;\n    mapping (address => uint256) private _atBlock;\n    mapping (address => uint256) private _cashBack;\n    mapping (address => uint256) private _cashRef;\n    mapping (address => uint256) private _admComiss;\n    address private owner;\n    address private _getWebStats;\n    uint256 private _getFundStatsMap;\n    uint256 private stor_a;\n    uint256 private stor_b;\n    uint256 private stor_c;\n    uint256 private stor_d;\n    uint256 private stor_e;\n    uint256 private stor_f;\n    uint256 private stor_11;\n    uint256 private stor_12;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function investedRef(address _address) public view returns(uint256) { \n        return _investedRef[_address];\n    }\n\n    function getUserStats(address _address) public view returns(uint256, uint256, uint256, uint256, uint256, uint256, address) { \n        return (_invested[_address], _cashBack[_address], _cashBack[_address], _atBlock[_address], block.number, _atBlock[_address], _atBlock[_address]);\n    }\n\n    function invested(address _address) public view returns(uint256) { \n        return _invested[_address];\n    }\n\n    function atBlock(address _address) public view returns(uint256) { \n        return _atBlock[_address];\n    }\n\n    function getFundStatsMap() public view returns(uint256, uint256, uint256, uint256, uint256, uint256) { \n        return (_getFundStatsMap, stor_a, stor_b, stor_c, stor_d, stor_e, stor_f);\n    }\n\n    function cashBack(address _address) public view returns(uint256) { \n        return _cashBack[_address];\n    }\n\n    function cashRef(address _address) public view returns(uint256) { \n        return _cashRef[_address];\n    }\n\n    function admComiss(address _address) public view returns(uint256) { \n        return _admComiss[_address];\n    }\n\n    function payments(address _address) public view returns(uint256) { \n        return _payments[_address];\n    }\n\n    function getWebStats() public view returns(uint256, uint256, uint256, uint256, address, uint256, uint256) { \n        return (_getFundStatsMap, address(this).balance, stor_a, stor_b, _getWebStats, stor_11, stor_12);\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    fallback() external payable {\n        // Logic for the fallback function\n    }\n\n    receive() external payable {\n        // Logic for the receive function\n    }\n}\n```\nPlease note that this is a rough approximation of your original contract. The fallback and receive functions are placeholders for now, as the original behaviour of these functions from your decompiled code is quite complex and would need a more thorough analysis to translate into Solidity.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470661,
	"id": "chatcmpl-8R6X7fXkduebjR5AodQGYuLutmq91",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 09:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _payments; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _investedRef; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _cashBack; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _cashRef; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _admComiss; // STORAGE[0x6]\nuint256 _getFundStatsMap; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\naddress owner_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress _getWebStats; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction investedRef(address varg0) public nonPayable { \n    return address(_investedRef[varg0]);\n}\n\nfunction getUserStats(address varg0) public nonPayable { \n    v0 = varg0;\n    return _invested[v0], _cashBack[v0], _cashBack[v0], _atBlock[v0], block.number, _atBlock[v0], address(_atBlock[v0]);\n}\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction getFundStatsMap() public nonPayable { \n    MEM[64] = MEM[64] + 224;\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    v0 = v1 = 0;\n    while (v0 < 224) {\n        MEM[v0 + MEM[64]] = MEM[v0 + MEM[64]];\n        v0 += 32;\n    }\n    return _getFundStatsMap, stor_a, stor_b, stor_c, stor_d, stor_e, stor_f;\n}\n\nfunction cashBack(address varg0) public nonPayable { \n    return _cashBack[varg0];\n}\n\nfunction cashRef(address varg0) public nonPayable { \n    return _cashRef[varg0];\n}\n\nfunction admComiss(address varg0) public nonPayable { \n    return _admComiss[varg0];\n}\n\nfunction payments(address varg0) public nonPayable { \n    return _payments[varg0];\n}\n\nfunction getWebStats() public nonPayable { \n    return _getFundStatsMap, this.balance, stor_a, stor_b, _getWebStats, stor_11, stor_12;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    v0 = v1 = 0;\n    if (_invested[msg.sender]) {\n        v2 = v3 = 298;\n        v0 = v4 = 5900;\n        v0 = v5 = 274;\n        require(_atBlock[msg.sender] <= block.number);\n        v0 = v6 = block.number - _atBlock[msg.sender];\n        v2 = v7 = 286;\n        v0 = v8 = 10000;\n        v9 = v10 = _SafeMul(100, _invested[msg.sender]);\n    }\n    if (msg.value) {\n        require(msg.value >= 0x2386f26fc10000, 'msg.value must be >= 0.01 ether (10 finney)');\n        v2 = v11 = 791;\n        v0 = v12 = 100;\n        v9 = v13 = _SafeMul(10, msg.value);\n    } else {\n        v14 = v15 = _admComiss[owner_7_0_19];\n        if (_admComiss[owner_7_0_19]) {\n            v14 = v16 = msg.sender == owner_7_0_19;\n        }\n        if (v14) {\n            v0 = v17 = _admComiss[owner_7_0_19] + v0;\n            require(v17 >= v0);\n            _admComiss[owner_7_0_19] = 0;\n            stor_e += v17;\n        }\n        if (_cashRef[msg.sender]) {\n            v0 = v18 = _cashRef[msg.sender] + v0;\n            require(v18 >= v0);\n            _cashRef[msg.sender] = 0;\n            stor_d += v18;\n        }\n        if (_cashBack[msg.sender]) {\n            v0 += _cashBack[msg.sender];\n            require(v0 >= v0);\n            _cashBack[msg.sender] = 0;\n            stor_c += v0;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    if (v0) {\n        stor_b += v0;\n        _payments[msg.sender] += v0;\n        v19 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v19); // checks call status, propagates error data on error\n    }\n    exit;\n    while (v0 <= 0) {\n        require(v0 > 0);\n        if (v0) {\n            break;\n        }\n        assert(v0);\n        if (!_invested[msg.sender]) {\n            _getFundStatsMap += 1;\n        }\n        _invested[msg.sender] += msg.value;\n        _atBlock[msg.sender] = block.number;\n        stor_a += msg.value;\n        MEM[32] = 0;\n        if (_invested[msg.sender] > 0) {\n            stor_f += msg.value;\n        }\n        _getWebStats = msg.sender;\n        stor_11 = msg.value;\n        stor_12 = block.number;\n        _cashBack[msg.sender] += v0;\n        _cashRef[address(_investedRef[msg.sender])] += v0;\n        v0 = v9 / v0;\n        goto {'0x12a', '0x485', '0x4de', '0x417', '0x317', '0x11e'};\n        v9 = _SafeMul(v0, v0);\n        _admComiss[owner_7_0_19] += v0;\n        v20 = new bytes[](msg.data.length);\n        CALLDATACOPY(v20.data, 0, msg.data.length);\n        v0 = v21 = MEM[20 + v20];\n        if (!address(v21)) {\n            if (address(_investedRef[msg.sender])) {\n                v2 = v22 = 1246;\n                v0 = v23 = 100;\n                v9 = v24 = _SafeMul(5, msg.value);\n            }\n        } else {\n            require(address(v21) != msg.sender, 'referal must be != msg.sender');\n            v2 = v25 = 1047;\n            v0 = v26 = 100;\n            v9 = v27 = _SafeMul(5, msg.value);\n        }\n        _cashRef[address(v0)] += v0;\n        _cashRef[msg.sender] = address(v0) | ~0xffffffffffffffffffffffffffffffffffffffff & _cashRef[msg.sender];\n        if (!_cashRef[msg.sender]) {\n            v2 = v28 = 1157;\n            v0 = v29 = 100;\n            v9 = v30 = _SafeMul(5, msg.value);\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x481ea473) {\n            investedRef(address);\n        } else if (0x4e43603a == function_selector) {\n            getUserStats(address);\n        } else if (0x66b3f6bf == function_selector) {\n            invested(address);\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0x97b1b2b7 == function_selector) {\n            getFundStatsMap();\n        } else if (0x97fc93ab == function_selector) {\n            cashBack(address);\n        } else if (0xb920d0b4 == function_selector) {\n            cashRef(address);\n        } else if (0xce5dbc0b == function_selector) {\n            admComiss(address);\n        } else if (0xe2982c21 == function_selector) {\n            payments(address);\n        } else if (0xf831e962 == function_selector) {\n            getWebStats();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _payments; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _investedRef; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _cashBack; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _cashRef; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _admComiss; // STORAGE[0x6]\nuint256 _getFundStatsMap; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\naddress owner_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress _getWebStats; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction investedRef(address varg0) public nonPayable { \n    return address(_investedRef[varg0]);\n}\n\nfunction getUserStats(address varg0) public nonPayable { \n    v0 = varg0;\n    return _invested[v0], _cashBack[v0], _cashBack[v0], _atBlock[v0], block.number, _atBlock[v0], address(_atBlock[v0]);\n}\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction getFundStatsMap() public nonPayable { \n    MEM[64] = MEM[64] + 224;\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    v0 = v1 = 0;\n    while (v0 < 224) {\n        MEM[v0 + MEM[64]] = MEM[v0 + MEM[64]];\n        v0 += 32;\n    }\n    return _getFundStatsMap, stor_a, stor_b, stor_c, stor_d, stor_e, stor_f;\n}\n\nfunction cashBack(address varg0) public nonPayable { \n    return _cashBack[varg0];\n}\n\nfunction cashRef(address varg0) public nonPayable { \n    return _cashRef[varg0];\n}\n\nfunction admComiss(address varg0) public nonPayable { \n    return _admComiss[varg0];\n}\n\nfunction payments(address varg0) public nonPayable { \n    return _payments[varg0];\n}\n\nfunction getWebStats() public nonPayable { \n    return _getFundStatsMap, this.balance, stor_a, stor_b, _getWebStats, stor_11, stor_12;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    v0 = v1 = 0;\n    if (_invested[msg.sender]) {\n        v2 = v3 = 298;\n        v0 = v4 = 5900;\n        v0 = v5 = 274;\n        require(_atBlock[msg.sender] <= block.number);\n        v0 = v6 = block.number - _atBlock[msg.sender];\n        v2 = v7 = 286;\n        v0 = v8 = 10000;\n        v9 = v10 = _SafeMul(100, _invested[msg.sender]);\n    }\n    if (msg.value) {\n        require(msg.value >= 0x2386f26fc10000, 'msg.value must be >= 0.01 ether (10 finney)');\n        v2 = v11 = 791;\n        v0 = v12 = 100;\n        v9 = v13 = _SafeMul(10, msg.value);\n    } else {\n        v14 = v15 = _admComiss[owner_7_0_19];\n        if (_admComiss[owner_7_0_19]) {\n            v14 = v16 = msg.sender == owner_7_0_19;\n        }\n        if (v14) {\n            v0 = v17 = _admComiss[owner_7_0_19] + v0;\n            require(v17 >= v0);\n            _admComiss[owner_7_0_19] = 0;\n            stor_e += v17;\n        }\n        if (_cashRef[msg.sender]) {\n            v0 = v18 = _cashRef[msg.sender] + v0;\n            require(v18 >= v0);\n            _cashRef[msg.sender] = 0;\n            stor_d += v18;\n        }\n        if (_cashBack[msg.sender]) {\n            v0 += _cashBack[msg.sender];\n            require(v0 >= v0);\n            _cashBack[msg.sender] = 0;\n            stor_c += v0;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    if (v0) {\n        stor_b += v0;\n        _payments[msg.sender] += v0;\n        v19 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v19); // checks call status, propagates error data on error\n    }\n    exit;\n    while (v0 <= 0) {\n        require(v0 > 0);\n        if (v0) {\n            break;\n        }\n        assert(v0);\n        if (!_invested[msg.sender]) {\n            _getFundStatsMap += 1;\n        }\n        _invested[msg.sender] += msg.value;\n        _atBlock[msg.sender] = block.number;\n        stor_a += msg.value;\n        MEM[32] = 0;\n        if (_invested[msg.sender] > 0) {\n            stor_f += msg.value;\n        }\n        _getWebStats = msg.sender;\n        stor_11 = msg.value;\n        stor_12 = block.number;\n        _cashBack[msg.sender] += v0;\n        _cashRef[address(_investedRef[msg.sender])] += v0;\n        v0 = v9 / v0;\n        goto {'0x12a', '0x485', '0x4de', '0x417', '0x317', '0x11e'};\n        v9 = _SafeMul(v0, v0);\n        _admComiss[owner_7_0_19] += v0;\n        v20 = new bytes[](msg.data.length);\n        CALLDATACOPY(v20.data, 0, msg.data.length);\n        v0 = v21 = MEM[20 + v20];\n        if (!address(v21)) {\n            if (address(_investedRef[msg.sender])) {\n                v2 = v22 = 1246;\n                v0 = v23 = 100;\n                v9 = v24 = _SafeMul(5, msg.value);\n            }\n        } else {\n            require(address(v21) != msg.sender, 'referal must be != msg.sender');\n            v2 = v25 = 1047;\n            v0 = v26 = 100;\n            v9 = v27 = _SafeMul(5, msg.value);\n        }\n        _cashRef[address(v0)] += v0;\n        _cashRef[msg.sender] = address(v0) | ~0xffffffffffffffffffffffffffffffffffffffff & _cashRef[msg.sender];\n        if (!_cashRef[msg.sender]) {\n            v2 = v28 = 1157;\n            v0 = v29 = 100;\n            v9 = v30 = _SafeMul(5, msg.value);\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x481ea473) {\n            investedRef(address);\n        } else if (0x4e43603a == function_selector) {\n            getUserStats(address);\n        } else if (0x66b3f6bf == function_selector) {\n            invested(address);\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0x97b1b2b7 == function_selector) {\n            getFundStatsMap();\n        } else if (0x97fc93ab == function_selector) {\n            cashBack(address);\n        } else if (0xb920d0b4 == function_selector) {\n            cashRef(address);\n        } else if (0xce5dbc0b == function_selector) {\n            admComiss(address);\n        } else if (0xe2982c21 == function_selector) {\n            payments(address);\n        } else if (0xf831e962 == function_selector) {\n            getWebStats();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _payments; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _investedRef; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _atBlock; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _cashBack; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _cashRef; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _admComiss; // STORAGE[0x6]\nuint256 _getFundStatsMap; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\naddress owner_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress _getWebStats; // STORAGE[0x10] bytes 0 to 19\n\n\nfunction investedRef(address varg0) public nonPayable { \n    return address(_investedRef[varg0]);\n}\n\nfunction getUserStats(address varg0) public nonPayable { \n    v0 = varg0;\n    return _invested[v0], _cashBack[v0], _cashBack[v0], _atBlock[v0], block.number, _atBlock[v0], address(_atBlock[v0]);\n}\n\nfunction invested(address varg0) public nonPayable { \n    return _invested[varg0];\n}\n\nfunction atBlock(address varg0) public nonPayable { \n    return _atBlock[varg0];\n}\n\nfunction getFundStatsMap() public nonPayable { \n    MEM[64] = MEM[64] + 224;\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    MEM[(MEM[64]) len 224] = this.code[this.code.size len 224];\n    v0 = v1 = 0;\n    while (v0 < 224) {\n        MEM[v0 + MEM[64]] = MEM[v0 + MEM[64]];\n        v0 += 32;\n    }\n    return _getFundStatsMap, stor_a, stor_b, stor_c, stor_d, stor_e, stor_f;\n}\n\nfunction cashBack(address varg0) public nonPayable { \n    return _cashBack[varg0];\n}\n\nfunction cashRef(address varg0) public nonPayable { \n    return _cashRef[varg0];\n}\n\nfunction admComiss(address varg0) public nonPayable { \n    return _admComiss[varg0];\n}\n\nfunction payments(address varg0) public nonPayable { \n    return _payments[varg0];\n}\n\nfunction getWebStats() public nonPayable { \n    return _getFundStatsMap, this.balance, stor_a, stor_b, _getWebStats, stor_11, stor_12;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    v0 = v1 = 0;\n    if (_invested[msg.sender]) {\n        v2 = v3 = 298;\n        v0 = v4 = 5900;\n        v0 = v5 = 274;\n        require(_atBlock[msg.sender] <= block.number);\n        v0 = v6 = block.number - _atBlock[msg.sender];\n        v2 = v7 = 286;\n        v0 = v8 = 10000;\n        v9 = v10 = _SafeMul(100, _invested[msg.sender]);\n    }\n    if (msg.value) {\n        require(msg.value >= 0x2386f26fc10000, 'msg.value must be >= 0.01 ether (10 finney)');\n        v2 = v11 = 791;\n        v0 = v12 = 100;\n        v9 = v13 = _SafeMul(10, msg.value);\n    } else {\n        v14 = v15 = _admComiss[owner_7_0_19];\n        if (_admComiss[owner_7_0_19]) {\n            v14 = v16 = msg.sender == owner_7_0_19;\n        }\n        if (v14) {\n            v0 = v17 = _admComiss[owner_7_0_19] + v0;\n            require(v17 >= v0);\n            _admComiss[owner_7_0_19] = 0;\n            stor_e += v17;\n        }\n        if (_cashRef[msg.sender]) {\n            v0 = v18 = _cashRef[msg.sender] + v0;\n            require(v18 >= v0);\n            _cashRef[msg.sender] = 0;\n            stor_d += v18;\n        }\n        if (_cashBack[msg.sender]) {\n            v0 += _cashBack[msg.sender];\n            require(v0 >= v0);\n            _cashBack[msg.sender] = 0;\n            stor_c += v0;\n        }\n    }\n    _atBlock[msg.sender] = block.number;\n    if (v0) {\n        stor_b += v0;\n        _payments[msg.sender] += v0;\n        v19 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v19); // checks call status, propagates error data on error\n    }\n    exit;\n    while (v0 <= 0) {\n        require(v0 > 0);\n        if (v0) {\n            break;\n        }\n        assert(v0);\n        if (!_invested[msg.sender]) {\n            _getFundStatsMap += 1;\n        }\n        _invested[msg.sender] += msg.value;\n        _atBlock[msg.sender] = block.number;\n        stor_a += msg.value;\n        MEM[32] = 0;\n        if (_invested[msg.sender] > 0) {\n            stor_f += msg.value;\n        }\n        _getWebStats = msg.sender;\n        stor_11 = msg.value;\n        stor_12 = block.number;\n        _cashBack[msg.sender] += v0;\n        _cashRef[address(_investedRef[msg.sender])] += v0;\n        v0 = v9 / v0;\n        goto {'0x12a', '0x485', '0x4de', '0x417', '0x317', '0x11e'};\n        v9 = _SafeMul(v0, v0);\n        _admComiss[owner_7_0_19] += v0;\n        v20 = new bytes[](msg.data.length);\n        CALLDATACOPY(v20.data, 0, msg.data.length);\n        v0 = v21 = MEM[20 + v20];\n        if (!address(v21)) {\n            if (address(_investedRef[msg.sender])) {\n                v2 = v22 = 1246;\n                v0 = v23 = 100;\n                v9 = v24 = _SafeMul(5, msg.value);\n            }\n        } else {\n            require(address(v21) != msg.sender, 'referal must be != msg.sender');\n            v2 = v25 = 1047;\n            v0 = v26 = 100;\n            v9 = v27 = _SafeMul(5, msg.value);\n        }\n        _cashRef[address(v0)] += v0;\n        _cashRef[msg.sender] = address(v0) | ~0xffffffffffffffffffffffffffffffffffffffff & _cashRef[msg.sender];\n        if (!_cashRef[msg.sender]) {\n            v2 = v28 = 1157;\n            v0 = v29 = 100;\n            v9 = v30 = _SafeMul(5, msg.value);\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x481ea473) {\n            investedRef(address);\n        } else if (0x4e43603a == function_selector) {\n            getUserStats(address);\n        } else if (0x66b3f6bf == function_selector) {\n            invested(address);\n        } else if (0x8aac1362 == function_selector) {\n            atBlock(address);\n        } else if (0x97b1b2b7 == function_selector) {\n            getFundStatsMap();\n        } else if (0x97fc93ab == function_selector) {\n            cashBack(address);\n        } else if (0xb920d0b4 == function_selector) {\n            cashRef(address);\n        } else if (0xce5dbc0b == function_selector) {\n            admComiss(address);\n        } else if (0xe2982c21 == function_selector) {\n            payments(address);\n        } else if (0xf831e962 == function_selector) {\n            getWebStats();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 56.814642906188965,
	"usage": {
		"completion_tokens": 743,
		"prompt_tokens": 2163,
		"total_tokens": 2906
	}
}