{
	"address": "0xf944d7740c0caf725bf26cf29e3facf6748189ac",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the provided decompiled code, the Solidity smart contract might look like the following:\n\n```Solidity\npragma solidity >=0.7.0 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    string private _name;\n    string private _symbol;\n    uint256 private _buyPrice;\n    uint256 private _totalSupply;\n    mapping (address => bool) private _frozenAccount;\n    address private _owner;\n    uint8 private _decimals;\n\n    event FrozenFunds(address target, bool frozen);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor (string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {\n        _owner = msg.sender;\n        _name = tokenName;\n        _symbol = tokenSymbol;\n        _decimals = decimalUnits;\n        _totalSupply = initialSupply;\n        _balanceOf[_owner] = _totalSupply;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint256 balance) {\n        return _balanceOf[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) {\n        return _allowance[tokenOwner][spender];\n    }\n\n    function approve(address spender, uint256 tokens) public returns (bool success) {\n        _allowance[msg.sender][spender] = tokens;\n        return true;\n    }\n\n    function transfer(address to, uint256 tokens) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= tokens);\n        require(!_frozenAccount[msg.sender]);\n        _balanceOf[msg.sender] -= tokens;\n        _balanceOf[to] += tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n        require(_balanceOf[from] >= tokens);\n        require(_allowance[from][msg.sender] >= tokens);\n        require(!_frozenAccount[from]);\n        _balanceOf[from] -= tokens;\n        _balanceOf[to] += tokens;\n        _allowance[from][msg.sender] -= tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function freezeAccount(address target, bool freeze) public {\n        require(msg.sender == _owner);\n        _frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\n    function setBuyPrice(uint256 newBuyPrice) public {\n        require(msg.sender == _owner);\n        _buyPrice = newBuyPrice;\n    }\n\n    function buy() public payable {\n        uint256 amount = msg.value / _buyPrice;\n        require(_balanceOf[_owner] >= amount);\n        _balanceOf[msg.sender] += amount;\n        _balanceOf[_owner] -= amount;\n        emit Transfer(_owner, msg.sender, amount);\n    }\n\n    function withdraw() public {\n        require(msg.sender == _owner);\n        payable(_owner).transfer(address(this).balance);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n    }\n}\n```\n\nPlease note that the decompiled code had some ambiguous parts and therefore might not be exactly translated in the above Solidity code.\n\nThe constructor, for instance, has been added to initialize the token with a name, symbol, decimals, and initial supply. Also, some parts of the code are depending on the EVM internals and don't have a direct translation to Solidity, so they were omitted. For example, parts that handle the fallback function or function selector.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470417,
	"id": "chatcmpl-8R6TBWGAb44X7nIpZKzuh64E8An92",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _buyPrice; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xc]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\n\n// Events\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction 0x1035(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    require(!(0xff & _frozenAccount[msg.sender]));\n    v0 = address(varg2);\n    require(_balanceOf[v0] > varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    v3 = _balanceOf[v2] + varg0;\n    assert(v3 >= _balanceOf[v2]);\n    require(v3 > _balanceOf[v1]);\n    v4 = address(varg2);\n    assert(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v4] - varg0;\n    v6 = address(varg1);\n    v7 = _balanceOf[v6] + varg0;\n    assert(v7 >= _balanceOf[v6]);\n    v8 = address(varg1);\n    _balanceOf[v8] = v7;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozenAccount[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x1035(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setbuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    0x6ef();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    0x1035(varg1, varg0, msg.sender);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg0 != _owner);\n    _owner = varg0;\n}\n\nfunction 0x6ef() private { \n    require(msg.value > 0);\n    require(_buyPrice > 0);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * _buyPrice;\n        assert(msg.value);\n        assert(v1 / msg.value == _buyPrice);\n    } else {\n        v0 = v2 = 0;\n    }\n    0x1035(v0, msg.sender, _owner);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x6ef();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9e6985e2 == function_selector) {\n            setbuyPrice(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _buyPrice; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xc]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\n\n// Events\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction 0x1035(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    require(!(0xff & _frozenAccount[msg.sender]));\n    v0 = address(varg2);\n    require(_balanceOf[v0] > varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    v3 = _balanceOf[v2] + varg0;\n    assert(v3 >= _balanceOf[v2]);\n    require(v3 > _balanceOf[v1]);\n    v4 = address(varg2);\n    assert(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v4] - varg0;\n    v6 = address(varg1);\n    v7 = _balanceOf[v6] + varg0;\n    assert(v7 >= _balanceOf[v6]);\n    v8 = address(varg1);\n    _balanceOf[v8] = v7;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozenAccount[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x1035(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setbuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    0x6ef();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    0x1035(varg1, varg0, msg.sender);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg0 != _owner);\n    _owner = varg0;\n}\n\nfunction 0x6ef() private { \n    require(msg.value > 0);\n    require(_buyPrice > 0);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * _buyPrice;\n        assert(msg.value);\n        assert(v1 / msg.value == _buyPrice);\n    } else {\n        v0 = v2 = 0;\n    }\n    0x1035(v0, msg.sender, _owner);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x6ef();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9e6985e2 == function_selector) {\n            setbuyPrice(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256[] _name; // STORAGE[0x7]\nuint256[] _symbol; // STORAGE[0x8]\nuint256 _buyPrice; // STORAGE[0xa]\nuint256 _totalSupply; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0xc]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x9] bytes 0 to 0\n\n// Events\nFrozenFunds(address, bool);\nTransfer(address, address, uint256);\n\nfunction 0x1035(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    require(!(0xff & _frozenAccount[msg.sender]));\n    v0 = address(varg2);\n    require(_balanceOf[v0] > varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    v3 = _balanceOf[v2] + varg0;\n    assert(v3 >= _balanceOf[v2]);\n    require(v3 > _balanceOf[v1]);\n    v4 = address(varg2);\n    assert(varg0 <= _balanceOf[v4]);\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v4] - varg0;\n    v6 = address(varg1);\n    v7 = _balanceOf[v6] + varg0;\n    assert(v7 >= _balanceOf[v6]);\n    v8 = address(varg1);\n    _balanceOf[v8] = v7;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozenAccount[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x1035(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setbuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    0x6ef();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    0x1035(varg1, varg0, msg.sender);\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v1 = v2 = 0;\n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    require(varg0 != _owner);\n    _owner = varg0;\n}\n\nfunction 0x6ef() private { \n    require(msg.value > 0);\n    require(_buyPrice > 0);\n    if (msg.value != 0) {\n        v0 = v1 = msg.value * _buyPrice;\n        assert(msg.value);\n        assert(v1 / msg.value == _buyPrice);\n    } else {\n        v0 = v2 = 0;\n    }\n    0x1035(v0, msg.sender, _owner);\n    return ;\n}\n\nfunction fallback() public payable { \n    0x6ef();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9e6985e2 == function_selector) {\n            setbuyPrice(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 32.678269147872925,
	"usage": {
		"completion_tokens": 856,
		"prompt_tokens": 2508,
		"total_tokens": 3364
	}
}