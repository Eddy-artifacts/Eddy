{
	"address": "0x7fea965a502f3f17851a57bcc57e95e03d83e98a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code equivalent to the provided EVM bytecode:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ncontract SmartContract {\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    uint public totalSupply;\n    address public owner;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    constructor(uint _initialSupply, string memory _name, string memory _symbol, uint8 _decimals) {\n        balanceOf[msg.sender] = totalSupply = _initialSupply;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance.\");\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value, \"Insufficient balance.\");\n        require(allowance[_from][msg.sender] >= _value, \"Insufficient allowance.\");\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n```\n\nPlease note that this is a simple token contract based on the ERC20 standard. The actual contract might include additional features, such as a minting function for creating new tokens, a burning function for destroying tokens, or an owning function for contract management purposes.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470446,
	"id": "chatcmpl-8R6TejcVn5ppopAhbrwlmdDEsJttr",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 09:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x8]\nuint256[] _symbol; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 _powerOfTen; // STORAGE[0xc]\nuint256 _sellPrice; // STORAGE[0xd]\nuint256 _buyPrice; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _stakedBalance; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _escrowedBalance; // STORAGE[0x13]\nuint160 _theAO; // STORAGE[0x0] bytes 0 to 19\nuint256 _primordialTotalSupply; // STORAGE[0x1d]\nuint256 _primordialTotalBought; // STORAGE[0x1e]\nuint256 _primordialSellPrice; // STORAGE[0x1f]\nuint256 _primordialBuyPrice; // STORAGE[0x20]\nuint256 _totalEthForPrimordial; // STORAGE[0x21]\nuint256 _totalRedeemedAOETH; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _primordialBalanceOf; // STORAGE[0x23]\nmapping (uint256 => [uint256]) _primordialAllowance; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _primordialStakedBalance; // STORAGE[0x25]\nmapping (uint256 => [uint256]) _weightedMultiplierByAddress; // STORAGE[0x27]\nmapping (uint256 => [uint256]) owner_28; // STORAGE[0x28]\nuint8 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint160 _nameTAOPositionAddress; // STORAGE[0x1] bytes 0 to 19\nuint8 _networkExchangeEnded; // STORAGE[0x26] bytes 0 to 0\nuint160 _namePublicKeyAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _nameAccountRecoveryAddress; // STORAGE[0x4] bytes 0 to 19\naddress _transferPrimordialBetweenPublicKeys; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\nuint160 _aoIonLotAddress; // STORAGE[0x14] bytes 0 to 19\nuint160 _settingTAOId; // STORAGE[0x15] bytes 0 to 19\nuint160 _aoSettingAddress; // STORAGE[0x16] bytes 0 to 19\nuint160 _aoethAddress; // STORAGE[0x17] bytes 0 to 19\nuint160 _aoDevTeam1; // STORAGE[0x18] bytes 0 to 19\nuint160 _aoDevTeam2; // STORAGE[0x19] bytes 0 to 19\naddress _maxMultiplierByAddress; // STORAGE[0x1a] bytes 0 to 19\naddress stor_1b_0_19; // STORAGE[0x1b] bytes 0 to 19\naddress stor_1c_0_19; // STORAGE[0x1c] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nNetworkExchangeEnded();\nBuyPrimordial(address, bytes32, uint8, uint256, uint256);\nPrimordialBurn(address, uint256);\nPrimordialStake(address, uint256, uint256);\nStake(address, uint256);\nBurn(address, uint256);\nUnstake(address, uint256);\nEscrow(address, address, uint256);\nUnescrow(address, uint256);\nFrozenFunds(address, bool);\nPrimordialUnstake(address, uint256, uint256);\nPrimordialApproval(address, address, uint256);\nTransfer(address, address, uint256);\nPrimordialTransfer(address, address, uint256);\n\nfunction burnPrimordialFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg1 <= _primordialAllowance[msg.sender]);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    v1 = 0x3b1f(varg1, varg0);\n    _weightedMultiplierByAddress[varg0] = v1;\n    assert(varg1 <= _weightedMultiplierByAddress[varg0]);\n    _primordialBalanceOf[varg0] = _weightedMultiplierByAddress[varg0] - varg1;\n    assert(varg1 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg1;\n    assert(varg1 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg1;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(varg0, varg1, _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction calculateMultiplierAfterConversion(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction primordialAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialAllowance[varg1];\n}\n\nfunction calculateMultiplierAfterBurn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction setAOETHAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoethAddress = varg0;\n    stor_1c_0_19 = varg0;\n}\n\nfunction setAOIonLotAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoIonLotAddress = varg0;\n    _maxMultiplierByAddress = varg0;\n}\n\nfunction setSettingTAOId(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.isTAO(varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    _settingTAOId = varg0;\n}\n\nfunction mintEscrow(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] += varg1;\n    assert(varg1 + _totalSupply >= _totalSupply);\n    _totalSupply += varg1;\n    emit Escrow(this, varg0, varg1);\n    return 1;\n}\n\nfunction namePublicKeyAddress() public nonPayable { \n    return _namePublicKeyAddress;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0 < _sellPrice);\n    v0 = 0x56b2(_sellPrice, varg0);\n    require((address(this)).balance >= v0);\n    0x53f5(varg0, this, msg.sender);\n    v1 = 0x56b2(_sellPrice, varg0);\n    v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction settingTAOId() public nonPayable { \n    return _settingTAOId;\n}\n\nfunction transferEth(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    v2 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction calculateMaximumBurnAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction approvePrimordialAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _theAO = varg0;\n}\n\nfunction unstakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialStakedBalance[varg0]);\n    assert(varg1 <= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] = _primordialStakedBalance[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialBalanceOf[varg0] = varg1 + _primordialStakedBalance[varg0];\n    emit PrimordialUnstake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction buyPrimordial() public payable { \n    v0 = v1 = msg.value;\n    v0 = v2 = 1;\n    v0 = v3 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v4 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v5 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v6 = v1 > 0;\n    }\n    if (v0) {\n        v7 = 0x32c1();\n        v0 = v8 = v7 > 0;\n    }\n    if (v0) {\n        if (v2) {\n            v0 = v9 = 0;\n            v10 = 0x48af();\n            v0 = v11 = v10 > 17903;\n        }\n        if (!v0) {\n            v0 = v12 = !v0;\n            if (v12) {\n                require(stor_1c_0_19.code.size);\n                v13, v14 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v13); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v15 = _totalRedeemedAOETH < v14;\n            }\n        }\n    }\n    require(v0);\n    v16, v17, v18 = 0x510f(1);\n    require(v18 > 0);\n    if (v16) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v17 <= msg.value);\n    assert(msg.value - v17 + _totalEthForPrimordial >= _totalEthForPrimordial);\n    _totalEthForPrimordial += msg.value - v17;\n    v19 = 0x5240(msg.sender, v18);\n    emit BuyPrimordial(msg.sender, v19, 1, msg.value, v17);\n    if (v17 > 0) {\n        v20 = msg.sender.call().value(v17).gas(2300 * !v17);\n        require(v20); // checks call status, propagates error data on error\n    }\n}\n\nfunction convertToPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[msg.sender], _weightedMultiplierByAddress[msg.sender], varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    0x56f0(varg0, msg.sender);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createConvertLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return 1;\n}\n\nfunction availableETH() public nonPayable { \n    v0 = 0x48af();\n    return v0;\n}\n\nfunction aoethAddress() public nonPayable { \n    return _aoethAddress;\n}\n\nfunction approvePrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x1597() private { \n    assert(_primordialTotalBought <= 0xc000000000000);\n    return 0xc000000000000 - _primordialTotalBought;\n}\n\nfunction 0x32c1() private { \n    v0 = 0x1597();\n    v1 = 0x56b2(_primordialBuyPrice, v0);\n    return v1;\n}\n\nfunction 0x3b1f(uint256 varg0, uint256 varg1) private { \n    v0 = 0x42a1(varg1);\n    require(v0 >= varg0);\n    v1 = address(varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[v1], _weightedMultiplierByAddress[v1], varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v3;\n}\n\nfunction 0x42a1(uint256 varg0) private { \n    v0 = address(varg0);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[v0], _weightedMultiplierByAddress[v0], _weightedMultiplierByAddress[v0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction 0x48af() private { \n    v0 = v1 = 0;\n    v2 = 0x32c1();\n    if (v2 <= v1) {\n        v3 = v4 = 0;\n    } else {\n        v0 = v5 = 0;\n        v0 = v6 = 18792;\n        v0 = v7 = 18772;\n        v3 = v8 = _totalRedeemedAOETH;\n        require(stor_1c_0_19.code.size);\n        v9, v10 = stor_1c_0_19.totalSupply().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v3 > v10) {\n            v3 = v10 - v3;\n            goto {'0x4968', '0x4954'};\n            v10 = v11 = 0x32c1();\n        }\n        throw();\n        v12 = 0x1597();\n        v13 = v14 = 1 == v12;\n        if (v14) {\n            v13 = v15 = v3 < _primordialBuyPrice;\n        }\n        if (v13) {\n            v3 = v16 = _primordialBuyPrice;\n        }\n    }\n    return v3;\n}\n\nfunction 0x4a27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = 0x57c4(_weightedMultiplierByAddress[v0], varg0, varg1);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3, v4 = _maxMultiplierByAddress.lotById(v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 128);\n    require(address(varg1) == address(v4));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v7, v8 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v6], varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v9 = address(varg1);\n    _weightedMultiplierByAddress[v9] = v8;\n    require(address(varg1));\n    v10 = address(varg2);\n    require(varg0 <= _primordialBalanceOf[v10]);\n    v11 = address(varg1);\n    v12 = varg0 + _primordialBalanceOf[v11];\n    assert(v12 >= _primordialBalanceOf[v11]);\n    require(v12 >= _primordialBalanceOf[v11]);\n    v13 = address(varg2);\n    require(!(0xff & _frozenAccount[v13]));\n    v14 = address(varg1);\n    require(!(0xff & _frozenAccount[v14]));\n    v15 = address(varg1);\n    v16 = address(varg2);\n    assert(_primordialBalanceOf[v15] + _primordialBalanceOf[v16] >= _primordialBalanceOf[v16]);\n    v17 = address(varg2);\n    assert(varg0 <= _primordialBalanceOf[v17]);\n    v18 = address(varg2);\n    _primordialBalanceOf[v18] = _primordialBalanceOf[v17] - varg0;\n    v19 = address(varg1);\n    v20 = varg0 + _primordialBalanceOf[v19];\n    assert(v20 >= _primordialBalanceOf[v19]);\n    v21 = address(varg1);\n    _primordialBalanceOf[v21] = v20;\n    emit PrimordialTransfer(address(varg2), v21, varg0);\n    v22 = address(varg1);\n    v23 = address(varg2);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] >= _primordialBalanceOf[v23]);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] == _primordialBalanceOf[v15] + _primordialBalanceOf[v16]);\n    require(1);\n    return 1;\n}\n\nfunction 0x4c19() private { \n    require(stor_1b_0_19.code.size);\n    v0, v1 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingPrimordialMultiplier').gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v1 + 128] <= 0x100000000);\n    require(v1 + MEM[v1 + 128] + 32 <= v1 + RETURNDATASIZE());\n    require(!((v1 + RETURNDATASIZE() < MEM[v1 + MEM[v1 + 128]] + (v1 + MEM[v1 + 128] + 32)) | (MEM[v1 + MEM[v1 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v2, v3 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingPrimordialMultiplier').gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    RETURNDATACOPY(v3, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v3 + 128] <= 0x100000000);\n    require(v3 + MEM[v3 + 128] + 32 <= v3 + RETURNDATASIZE());\n    require(!((v3 + RETURNDATASIZE() < MEM[v3 + MEM[v3 + 128]] + (v3 + MEM[v3 + 128] + 32)) | (MEM[v3 + MEM[v3 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v4, v5 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingNetworkBonusMultiplier').gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v5 + 128] <= 0x100000000);\n    require(v5 + MEM[v5 + 128] + 32 <= v5 + RETURNDATASIZE());\n    require(!((v5 + RETURNDATASIZE() < MEM[v5 + MEM[v5 + 128]] + (v5 + MEM[v5 + 128] + 32)) | (MEM[v5 + MEM[v5 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v6, v7 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingNetworkBonusMultiplier').gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v7 + 128] <= 0x100000000);\n    require(v7 + MEM[v7 + 128] + 32 <= v7 + RETURNDATASIZE());\n    require(!((v7 + RETURNDATASIZE() < MEM[v7 + MEM[v7 + 128]] + (v7 + MEM[v7 + 128] + 32)) | (MEM[v7 + MEM[v7 + 128]] > 0x100000000)));\n    return MEM[v7], MEM[v5], MEM[v3], MEM[v1];\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction availablePrimordialForSale() public nonPayable { \n    v0 = 0x1597();\n    return v0;\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction 0x510f(uint256 varg0) private { \n    v0 = v1 = 0;\n    assert(_primordialBuyPrice);\n    v2 = 0x56b2(_primordialBuyPrice, v0 / _primordialBuyPrice);\n    assert(v2 <= v0);\n    v3 = v4 = v0 - v2;\n    v3 = v5 = 0;\n    v3 = v6 = 0x48af();\n    if (v1) {\n        v3 = v7 = 20849;\n        v8 = 0x48af();\n        v0 = v9 = v1 > v8;\n    }\n    if (v0) {\n        assert(_primordialBuyPrice);\n        v3 = v10 = v3 / _primordialBuyPrice;\n        v11 = 0x56b2(_primordialBuyPrice, v10);\n        assert(v11 <= v0);\n        v3 = v12 = v0 - v11;\n    }\n    v13 = v14 = 0;\n    assert(v3 + _primordialTotalBought >= _primordialTotalBought);\n    if (v3 + _primordialTotalBought >= 0xc000000000000) {\n        assert(_primordialTotalBought <= 0xc000000000000);\n        v3 = v15 = 0xc000000000000 - _primordialTotalBought;\n        v13 = v16 = 1;\n        v17 = 0x56b2(_primordialBuyPrice, v15);\n        assert(v17 <= v0);\n        v3 = v0 - v17;\n    }\n    return v13, v3, v3;\n}\n\nfunction 0x5240(uint256 varg0, uint256 varg1) private { \n    v0, v1, v2, v3 = 0x4c19();\n    v4, v5, v6, v7 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg1, 0xc000000000000, _primordialTotalBought, v7, v6).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v10, v11 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v12, v13 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v14 = varg1 + _primordialTotalBought;\n    assert(v14 >= _primordialTotalBought);\n    _primordialTotalBought = v14;\n    v15 = 0x5b31(v13, MEM[MEM[64]], varg1, varg0);\n    assert(MEM[MEM[64]] <= v3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v16, v17 = 0x1150d53299abb7de27464d01b626728f5c840229.PERCENTAGE_DIVISOR().gas(msg.gas);\n    require(v16); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] <= v1);\n    assert(v0 + (v1 - MEM[MEM[64]]) >= v1 - MEM[MEM[64]]);\n    v18 = 0x56b2(varg1, v0 + (v1 - MEM[MEM[64]]));\n    assert(v17);\n    if (_aoDevTeam1) {\n        v19 = v20 = 21401;\n        v21 = v22 = _aoDevTeam1;\n        assert(2);\n        v23 = v24 = varg1 >> 1;\n    }\n    assert(2);\n    v25 = 0x5b31(v18 / v17 >> 1, v3 - MEM[MEM[64]], v23, v21);\n    if (_aoDevTeam2) {\n        v19 = v26 = 21453;\n        v21 = v27 = _aoDevTeam2;\n        assert(2);\n        v23 = varg1 >> 1;\n        goto 0x5382;\n    }\n    0x55de(v18 / v17, _theAO);\n    return v15;\n}\n\nfunction setAOSettingAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoSettingAddress = varg0;\n    stor_1b_0_19 = varg0;\n}\n\nfunction 0x53f5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    v2 = varg0 + _balanceOf[v1];\n    assert(v2 >= _balanceOf[v1]);\n    require(v2 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    assert(_balanceOf[v5] + _balanceOf[v6] >= _balanceOf[v6]);\n    v7 = address(varg2);\n    assert(varg0 <= _balanceOf[v7]);\n    v8 = address(varg2);\n    _balanceOf[v8] = _balanceOf[v7] - varg0;\n    v9 = address(varg1);\n    v10 = varg0 + _balanceOf[v9];\n    assert(v10 >= _balanceOf[v9]);\n    v11 = address(varg1);\n    _balanceOf[v11] = v10;\n    emit Transfer(address(varg2), v11, varg0);\n    v12 = address(varg1);\n    v13 = address(varg2);\n    assert(_balanceOf[v12] + _balanceOf[v13] >= _balanceOf[v13]);\n    assert(_balanceOf[v12] + _balanceOf[v13] == _balanceOf[v5] + _balanceOf[v6]);\n    return ;\n}\n\nfunction 0x55de(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _balanceOf[v0];\n    assert(v1 >= _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    v3 = varg0 + _totalSupply;\n    assert(v3 >= _totalSupply);\n    _totalSupply = v3;\n    emit Transfer(0, this, varg0);\n    emit Transfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x56b2(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x56f0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _primordialBalanceOf[v0];\n    assert(v1 >= _primordialBalanceOf[v0]);\n    v2 = address(varg1);\n    _primordialBalanceOf[v2] = v1;\n    v3 = varg0 + _primordialTotalSupply;\n    assert(v3 >= _primordialTotalSupply);\n    _primordialTotalSupply = v3;\n    emit PrimordialTransfer(0, this, varg0);\n    emit PrimordialTransfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction 0x57c4(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    require(varg1 > 0);\n    v0 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createWeightedMultiplierLot(v0, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v4, v5 = _maxMultiplierByAddress.totalLotsByAddress(v3).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 != v5) {\n        return v2;\n    } else {\n        v6 = address(varg2);\n        owner_28[v6] = varg0;\n        return v2;\n    }\n}\n\nfunction 0x5b31(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createPrimordialLot(v0, varg2, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v3], _weightedMultiplierByAddress[v3], varg1, varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = address(varg3);\n    _weightedMultiplierByAddress[v6] = v5;\n    require(_maxMultiplierByAddress.code.size);\n    v7, v8 = _maxMultiplierByAddress.totalLotsByAddress(v6).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 == v8) {\n        v9 = address(varg3);\n        owner_28[v9] = varg1;\n    }\n    0x56f0(varg2, varg3);\n    0x55de(varg0, varg3);\n    return v2;\n}\n\nfunction transferPrimordialBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    v10 = 0x4a27(varg3, varg2, varg1);\n    return v10;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[msg.sender] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction powerOfTen() public nonPayable { \n    return _powerOfTen;\n}\n\nfunction calculateMultiplierAndBonus(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0, v1, v2, v3 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg0, 0xc000000000000, _primordialTotalBought, v3, v2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v6, v7 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return MEM[MEM[64]], MEM[MEM[64]], v9;\n}\n\nfunction buyPrimordialWithAOETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0;\n    v0 = v2 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v3 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v4 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v5 = varg0 > 0;\n    }\n    if (v0) {\n        v6 = 0x32c1();\n        v0 = v7 = v6 > 0;\n    }\n    if (v0) {\n        if (v1) {\n            v0 = v8 = 0;\n            v9 = 0x48af();\n            v0 = v10 = v9 > 7699;\n        }\n        if (!v0) {\n            v0 = v11 = !v0;\n            if (v11) {\n                require(stor_1c_0_19.code.size);\n                v12, v13 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v12); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v14 = _totalRedeemedAOETH < v13;\n            }\n        }\n    }\n    require(v0);\n    v15, v16, v17 = 0x510f(0);\n    require(v17 > 0);\n    if (v15) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v16 <= v0);\n    assert(v0 - v16 + _totalRedeemedAOETH >= _totalRedeemedAOETH);\n    _totalRedeemedAOETH += v0 - v16;\n    require(stor_1c_0_19.code.size);\n    v18, v19 = stor_1c_0_19.whitelistTransferFrom(msg.sender, this, v0 - v16).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v19);\n    v20 = 0x5240(msg.sender, v17);\n    emit BuyPrimordial(msg.sender, v20, 2, v0, v16);\n}\n\nfunction burnPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _primordialBalanceOf[msg.sender]);\n    v0 = 0x42a1(msg.sender);\n    require(v0 >= varg0);\n    v1 = 0x3b1f(varg0, msg.sender);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    assert(varg0 <= _weightedMultiplierByAddress[msg.sender]);\n    _primordialBalanceOf[msg.sender] = _weightedMultiplierByAddress[msg.sender] - varg0;\n    assert(varg0 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg0;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(msg.sender, varg0);\n    return 1;\n}\n\nfunction aoDevTeam1() public nonPayable { \n    return _aoDevTeam1;\n}\n\nfunction primordialStakedBalance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialStakedBalance[varg1];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction stakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg2 == _weightedMultiplierByAddress[varg0]);\n    assert(varg1 <= _primordialBalanceOf[varg0]);\n    _primordialBalanceOf[varg0] = _primordialBalanceOf[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] += varg1;\n    emit PrimordialStake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction aoSettingAddress() public nonPayable { \n    return _aoSettingAddress;\n}\n\nfunction setNameAccountRecoveryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameAccountRecoveryAddress = varg0;\n    stor_7_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x4];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction weightedMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _weightedMultiplierByAddress[varg0];\n}\n\nfunction primordialSellPrice() public nonPayable { \n    return _primordialSellPrice;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction stakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _stakedBalance[varg0] += varg1;\n    emit Stake(varg0, varg1);\n    return 1;\n}\n\nfunction totalRedeemedAOETH() public nonPayable { \n    return _totalRedeemedAOETH;\n}\n\nfunction maxMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_maxMultiplierByAddress.code.size);\n    v0, v1 = _maxMultiplierByAddress.totalLotsByAddress(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        v2 = v3 = owner_28[varg0];\n        goto 0x4e90x93b;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x55de(varg1, varg0);\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction nameTAOPositionAddress() public nonPayable { \n    return _nameTAOPositionAddress;\n}\n\nfunction escrowedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _escrowedBalance[varg0];\n}\n\nfunction setWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _whitelist[varg0] = varg1 | ~0xff & _whitelist[varg0];\n}\n\nfunction primordialBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _primordialBalanceOf[varg0];\n}\n\nfunction setNameTAOPositionAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameTAOPositionAddress = varg0;\n    _transferPrimordialBetweenPublicKeys = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x1];\n}\n\nfunction stakedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _stakedBalance[varg0];\n}\n\nfunction endNetworkExchange() public nonPayable { \n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(!_networkExchangeEnded);\n    _networkExchangeEnded = 1;\n    emit NetworkExchangeEnded();\n}\n\nfunction TOTAL_PRIMORDIAL_FOR_SALE() public nonPayable { \n    return 0xc000000000000;\n}\n\nfunction setNamePublicKeyAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _namePublicKeyAddress = varg0;\n    stor_6_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x3];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction primordialBuyPrice() public nonPayable { \n    return _primordialBuyPrice;\n}\n\nfunction unstakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _stakedBalance[varg0]);\n    assert(varg1 <= _stakedBalance[varg0]);\n    _stakedBalance[varg0] = _stakedBalance[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _stakedBalance[varg0];\n    emit Unstake(varg0, varg1);\n    return 1;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction transferBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    0x53f5(varg3, varg2, varg1);\n    return 1;\n}\n\nfunction primordialTotalSupply() public nonPayable { \n    return _primordialTotalSupply;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction escrowFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _escrowedBalance[varg1] >= _escrowedBalance[varg1]);\n    _escrowedBalance[varg1] += varg2;\n    emit Escrow(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction unescrowFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _escrowedBalance[varg0]);\n    assert(varg1 <= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] = _escrowedBalance[varg0] - varg1;\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _escrowedBalance[varg0];\n    emit Unescrow(varg0, varg1);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelist[varg0];\n}\n\nfunction availablePrimordialForSaleInETH() public nonPayable { \n    v0 = 0x32c1();\n    return v0;\n}\n\nfunction whitelistTransferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction totalEthForPrimordial() public nonPayable { \n    return _totalEthForPrimordial;\n}\n\nfunction nameAccountRecoveryAddress() public nonPayable { \n    return _nameAccountRecoveryAddress;\n}\n\nfunction networkExchangeEnded() public nonPayable { \n    return _networkExchangeEnded;\n}\n\nfunction buy() public payable { \n    require(0 < _buyPrice);\n    assert(_buyPrice);\n    0x53f5(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x53f5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction setPrimordialPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _primordialSellPrice = varg0;\n    _primordialBuyPrice = varg1;\n}\n\nfunction aoDevTeam2() public nonPayable { \n    return _aoDevTeam2;\n}\n\nfunction theAO() public nonPayable { \n    return _theAO;\n}\n\nfunction aoIonLotAddress() public nonPayable { \n    return _aoIonLotAddress;\n}\n\nfunction primordialTotalBought() public nonPayable { \n    return _primordialTotalBought;\n}\n\nfunction transferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _primordialAllowance[msg.sender]);\n    assert(varg2 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg2;\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistBurnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction setAODevTeamAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _aoDevTeam1 = varg0;\n    _aoDevTeam2 = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction transferPrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x4a27(varg1, varg0, msg.sender);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x95d89b41 > v0) {\n            if (0x3a9c7d3d > v0) {\n                if (0x153d9049 > v0) {\n                    if (0x95ea7b3 > v0) {\n                        if (0x32b7006 == v0) {\n                            availablePrimordialForSale();\n                        } else if (0x5fefda7 == v0) {\n                            setPrices(uint256,uint256);\n                        } else if (0x6fd7088 == v0) {\n                            setAOSettingAddress(address);\n                        } else if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x7f09e9a == v0) {\n                            transferPrimordialBetweenPublicKeys(address,address,address,uint256);\n                        }\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0xaa24546 == v0) {\n                        powerOfTen();\n                    } else if (0xac0b31f == v0) {\n                        calculateMultiplierAndBonus(uint256);\n                    } else if (0xde8e272 == v0) {\n                        buyPrimordialWithAOETH(uint256);\n                    } else if (0xe93571b == v0) {\n                        burnPrimordial(uint256);\n                    } else if (0x15227aa7 == v0) {\n                        aoDevTeam1();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x153d9049 == v0) {\n                        primordialStakedBalance(address,uint256);\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x18ff5c51 == v0) {\n                        stakePrimordialFrom(address,uint256,uint256);\n                    } else if (0x1d0138ff == v0) {\n                        aoSettingAddress();\n                    } else if (0x1dfde2bd == v0) {\n                        setNameAccountRecoveryAddress(address);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x281bdaf8 == v0) {\n                    weightedMultiplierByAddress(address);\n                } else if (0x2b687bb9 == v0) {\n                    primordialSellPrice();\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x31a8aeb3 == v0) {\n                    stakeFrom(address,uint256);\n                } else if (0x3480e251 == v0) {\n                    totalRedeemedAOETH();\n                }\n            } else if (0x6aae86c3 > v0) {\n                if (0x4fbd2695 > v0) {\n                    if (0x3a9c7d3d == v0) {\n                        maxMultiplierByAddress(address);\n                    } else if (0x40c10f19 == v0) {\n                        mint(address,uint256);\n                    } else if (0x42966c68 == v0) {\n                        burn(uint256);\n                    } else if (0x4b750334 == v0) {\n                        sellPrice();\n                    } else if (0x4ef033f0 == v0) {\n                        nameTAOPositionAddress();\n                    }\n                } else if (0x4fbd2695 == v0) {\n                    escrowedBalance(address);\n                } else if (0x53d6fd59 == v0) {\n                    setWhitelist(address,bool);\n                } else if (0x57946b8e == v0) {\n                    primordialBalanceOf(address);\n                } else if (0x5cfaf2ef == v0) {\n                    setNameTAOPositionAddress(address);\n                } else if (0x60217267 == v0) {\n                    stakedBalance(address);\n                } else if (0x6a015bbe == v0) {\n                    endNetworkExchange();\n                }\n            } else if (0x79cc6790 > v0) {\n                if (0x6aae86c3 == v0) {\n                    TOTAL_PRIMORDIAL_FOR_SALE();\n                } else if (0x6d9aa034 == v0) {\n                    setNamePublicKeyAddress(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x72d11466 == v0) {\n                    primordialBuyPrice();\n                } else if (0x731a3b06 == v0) {\n                    unstakeFrom(address,uint256);\n                }\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7d9e2a21 == v0) {\n                transferBetweenPublicKeys(address,address,address,uint256);\n            } else if (0x834e9f31 == v0) {\n                primordialTotalSupply();\n            } else if (0x8620410b == v0) {\n                buyPrice();\n            } else if (0x87d4ca93 == v0) {\n                escrowFrom(address,address,uint256);\n            } else if (0x8a066045 == v0) {\n                unescrowFrom(address,uint256);\n            }\n        } else if (0xcf3e194d > v0) {\n            if (0xa99433a6 > v0) {\n                if (0xa2e8760b > v0) {\n                    if (0x95d89b41 == v0) {\n                        symbol();\n                    } else if (0x9b19251a == v0) {\n                        whitelist(address);\n                    } else if (0x9d9b7396 == v0) {\n                        availablePrimordialForSaleInETH();\n                    } else if (0x9eeead7a == v0) {\n                        whitelistTransferPrimordialFrom(address,address,uint256);\n                    } else if (0xa144a3e0 == v0) {\n                        whitelistTransferFrom(address,address,uint256);\n                    }\n                } else if (0xa2e8760b == v0) {\n                    totalEthForPrimordial();\n                } else if (0xa4e5fad2 == v0) {\n                    nameAccountRecoveryAddress();\n                } else if (0xa545a5d1 == v0) {\n                    networkExchangeEnded();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xa9188878 == v0) {\n                    setPrimordialPrices(uint256,uint256);\n                }\n            } else if (0xb1e19d45 > v0) {\n                if (0xa99433a6 == v0) {\n                    aoDevTeam2();\n                } else if (0xa9b6b38e == v0) {\n                    theAO();\n                } else if (0xab13f751 == v0) {\n                    aoIonLotAddress();\n                } else if (0xab7f7706 == v0) {\n                    primordialTotalBought();\n                } else if (0xadc933cf == v0) {\n                    transferPrimordialFrom(address,address,uint256);\n                }\n            } else if (0xb1e19d45 == v0) {\n                whitelistBurnFrom(address,uint256);\n            } else if (0xb24626e9 == v0) {\n                setAODevTeamAddresses(address,address);\n            } else if (0xb414d4b6 == v0) {\n                frozenAccount(address);\n            } else if (0xb811ae7f == v0) {\n                transferPrimordial(address,uint256);\n            } else if (0xc3c1ac47 == v0) {\n                burnPrimordialFrom(address,uint256);\n            } else if (0xcae9ca51 == v0) {\n                approveAndCall(address,uint256,bytes);\n            }\n        } else if (0xe7c50185 > v0) {\n            if (0xd6830af3 > v0) {\n                if (0xcf3e194d == v0) {\n                    calculateMultiplierAfterConversion(address,uint256);\n                } else if (0xd1e5a552 == v0) {\n                    primordialAllowance(address,address);\n                } else if (0xd3183864 == v0) {\n                    calculateMultiplierAfterBurn(address,uint256);\n                } else if (0xd569aa25 == v0) {\n                    setAOETHAddress(address);\n                } else if (0xd64468bf == v0) {\n                    setAOIonLotAddress(address);\n                }\n            } else if (0xd6830af3 == v0) {\n                setSettingTAOId(address);\n            } else if (0xd6c9e189 == v0) {\n                mintEscrow(address,uint256);\n            } else if (0xd8ce52d1 == v0) {\n                namePublicKeyAddress();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe4849b32 == v0) {\n                sell(uint256);\n            } else if (0xe724529c == v0) {\n                freezeAccount(address,bool);\n            }\n        } else if (0xf81eb76d > v0) {\n            if (0xe7c50185 == v0) {\n                settingTAOId();\n            } else if (0xe9bb84c2 == v0) {\n                transferEth(address,uint256);\n            } else if (0xecbbd1ca == v0) {\n                calculateMaximumBurnAmount(address);\n            } else if (0xede5e884 == v0) {\n                approvePrimordialAndCall(address,uint256,bytes);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            }\n        } else if (0xf81eb76d == v0) {\n            unstakePrimordialFrom(address,uint256,uint256);\n        } else if (0xf9f43634 == v0) {\n            buyPrimordial();\n        } else if (0xfaaad91d == v0) {\n            convertToPrimordial(uint256);\n        } else if (0xfb6ff161 == v0) {\n            availableETH();\n        } else if (0xfdb52e86 == v0) {\n            aoethAddress();\n        } else if (0xfff17e9e == v0) {\n            approvePrimordial(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 09:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x8]\nuint256[] _symbol; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 _powerOfTen; // STORAGE[0xc]\nuint256 _sellPrice; // STORAGE[0xd]\nuint256 _buyPrice; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _stakedBalance; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _escrowedBalance; // STORAGE[0x13]\nuint160 _theAO; // STORAGE[0x0] bytes 0 to 19\nuint256 _primordialTotalSupply; // STORAGE[0x1d]\nuint256 _primordialTotalBought; // STORAGE[0x1e]\nuint256 _primordialSellPrice; // STORAGE[0x1f]\nuint256 _primordialBuyPrice; // STORAGE[0x20]\nuint256 _totalEthForPrimordial; // STORAGE[0x21]\nuint256 _totalRedeemedAOETH; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _primordialBalanceOf; // STORAGE[0x23]\nmapping (uint256 => [uint256]) _primordialAllowance; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _primordialStakedBalance; // STORAGE[0x25]\nmapping (uint256 => [uint256]) _weightedMultiplierByAddress; // STORAGE[0x27]\nmapping (uint256 => [uint256]) owner_28; // STORAGE[0x28]\nuint8 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint160 _nameTAOPositionAddress; // STORAGE[0x1] bytes 0 to 19\nuint8 _networkExchangeEnded; // STORAGE[0x26] bytes 0 to 0\nuint160 _namePublicKeyAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _nameAccountRecoveryAddress; // STORAGE[0x4] bytes 0 to 19\naddress _transferPrimordialBetweenPublicKeys; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\nuint160 _aoIonLotAddress; // STORAGE[0x14] bytes 0 to 19\nuint160 _settingTAOId; // STORAGE[0x15] bytes 0 to 19\nuint160 _aoSettingAddress; // STORAGE[0x16] bytes 0 to 19\nuint160 _aoethAddress; // STORAGE[0x17] bytes 0 to 19\nuint160 _aoDevTeam1; // STORAGE[0x18] bytes 0 to 19\nuint160 _aoDevTeam2; // STORAGE[0x19] bytes 0 to 19\naddress _maxMultiplierByAddress; // STORAGE[0x1a] bytes 0 to 19\naddress stor_1b_0_19; // STORAGE[0x1b] bytes 0 to 19\naddress stor_1c_0_19; // STORAGE[0x1c] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nNetworkExchangeEnded();\nBuyPrimordial(address, bytes32, uint8, uint256, uint256);\nPrimordialBurn(address, uint256);\nPrimordialStake(address, uint256, uint256);\nStake(address, uint256);\nBurn(address, uint256);\nUnstake(address, uint256);\nEscrow(address, address, uint256);\nUnescrow(address, uint256);\nFrozenFunds(address, bool);\nPrimordialUnstake(address, uint256, uint256);\nPrimordialApproval(address, address, uint256);\nTransfer(address, address, uint256);\nPrimordialTransfer(address, address, uint256);\n\nfunction burnPrimordialFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg1 <= _primordialAllowance[msg.sender]);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    v1 = 0x3b1f(varg1, varg0);\n    _weightedMultiplierByAddress[varg0] = v1;\n    assert(varg1 <= _weightedMultiplierByAddress[varg0]);\n    _primordialBalanceOf[varg0] = _weightedMultiplierByAddress[varg0] - varg1;\n    assert(varg1 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg1;\n    assert(varg1 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg1;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(varg0, varg1, _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction calculateMultiplierAfterConversion(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction primordialAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialAllowance[varg1];\n}\n\nfunction calculateMultiplierAfterBurn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction setAOETHAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoethAddress = varg0;\n    stor_1c_0_19 = varg0;\n}\n\nfunction setAOIonLotAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoIonLotAddress = varg0;\n    _maxMultiplierByAddress = varg0;\n}\n\nfunction setSettingTAOId(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.isTAO(varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    _settingTAOId = varg0;\n}\n\nfunction mintEscrow(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] += varg1;\n    assert(varg1 + _totalSupply >= _totalSupply);\n    _totalSupply += varg1;\n    emit Escrow(this, varg0, varg1);\n    return 1;\n}\n\nfunction namePublicKeyAddress() public nonPayable { \n    return _namePublicKeyAddress;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0 < _sellPrice);\n    v0 = 0x56b2(_sellPrice, varg0);\n    require((address(this)).balance >= v0);\n    0x53f5(varg0, this, msg.sender);\n    v1 = 0x56b2(_sellPrice, varg0);\n    v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction settingTAOId() public nonPayable { \n    return _settingTAOId;\n}\n\nfunction transferEth(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    v2 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction calculateMaximumBurnAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction approvePrimordialAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _theAO = varg0;\n}\n\nfunction unstakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialStakedBalance[varg0]);\n    assert(varg1 <= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] = _primordialStakedBalance[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialBalanceOf[varg0] = varg1 + _primordialStakedBalance[varg0];\n    emit PrimordialUnstake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction buyPrimordial() public payable { \n    v0 = v1 = msg.value;\n    v0 = v2 = 1;\n    v0 = v3 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v4 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v5 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v6 = v1 > 0;\n    }\n    if (v0) {\n        v7 = 0x32c1();\n        v0 = v8 = v7 > 0;\n    }\n    if (v0) {\n        if (v2) {\n            v0 = v9 = 0;\n            v10 = 0x48af();\n            v0 = v11 = v10 > 17903;\n        }\n        if (!v0) {\n            v0 = v12 = !v0;\n            if (v12) {\n                require(stor_1c_0_19.code.size);\n                v13, v14 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v13); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v15 = _totalRedeemedAOETH < v14;\n            }\n        }\n    }\n    require(v0);\n    v16, v17, v18 = 0x510f(1);\n    require(v18 > 0);\n    if (v16) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v17 <= msg.value);\n    assert(msg.value - v17 + _totalEthForPrimordial >= _totalEthForPrimordial);\n    _totalEthForPrimordial += msg.value - v17;\n    v19 = 0x5240(msg.sender, v18);\n    emit BuyPrimordial(msg.sender, v19, 1, msg.value, v17);\n    if (v17 > 0) {\n        v20 = msg.sender.call().value(v17).gas(2300 * !v17);\n        require(v20); // checks call status, propagates error data on error\n    }\n}\n\nfunction convertToPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[msg.sender], _weightedMultiplierByAddress[msg.sender], varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    0x56f0(varg0, msg.sender);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createConvertLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return 1;\n}\n\nfunction availableETH() public nonPayable { \n    v0 = 0x48af();\n    return v0;\n}\n\nfunction aoethAddress() public nonPayable { \n    return _aoethAddress;\n}\n\nfunction approvePrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x1597() private { \n    assert(_primordialTotalBought <= 0xc000000000000);\n    return 0xc000000000000 - _primordialTotalBought;\n}\n\nfunction 0x32c1() private { \n    v0 = 0x1597();\n    v1 = 0x56b2(_primordialBuyPrice, v0);\n    return v1;\n}\n\nfunction 0x3b1f(uint256 varg0, uint256 varg1) private { \n    v0 = 0x42a1(varg1);\n    require(v0 >= varg0);\n    v1 = address(varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[v1], _weightedMultiplierByAddress[v1], varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v3;\n}\n\nfunction 0x42a1(uint256 varg0) private { \n    v0 = address(varg0);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[v0], _weightedMultiplierByAddress[v0], _weightedMultiplierByAddress[v0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction 0x48af() private { \n    v0 = v1 = 0;\n    v2 = 0x32c1();\n    if (v2 <= v1) {\n        v3 = v4 = 0;\n    } else {\n        v0 = v5 = 0;\n        v0 = v6 = 18792;\n        v0 = v7 = 18772;\n        v3 = v8 = _totalRedeemedAOETH;\n        require(stor_1c_0_19.code.size);\n        v9, v10 = stor_1c_0_19.totalSupply().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v3 > v10) {\n            v3 = v10 - v3;\n            goto {'0x4968', '0x4954'};\n            v10 = v11 = 0x32c1();\n        }\n        throw();\n        v12 = 0x1597();\n        v13 = v14 = 1 == v12;\n        if (v14) {\n            v13 = v15 = v3 < _primordialBuyPrice;\n        }\n        if (v13) {\n            v3 = v16 = _primordialBuyPrice;\n        }\n    }\n    return v3;\n}\n\nfunction 0x4a27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = 0x57c4(_weightedMultiplierByAddress[v0], varg0, varg1);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3, v4 = _maxMultiplierByAddress.lotById(v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 128);\n    require(address(varg1) == address(v4));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v7, v8 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v6], varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v9 = address(varg1);\n    _weightedMultiplierByAddress[v9] = v8;\n    require(address(varg1));\n    v10 = address(varg2);\n    require(varg0 <= _primordialBalanceOf[v10]);\n    v11 = address(varg1);\n    v12 = varg0 + _primordialBalanceOf[v11];\n    assert(v12 >= _primordialBalanceOf[v11]);\n    require(v12 >= _primordialBalanceOf[v11]);\n    v13 = address(varg2);\n    require(!(0xff & _frozenAccount[v13]));\n    v14 = address(varg1);\n    require(!(0xff & _frozenAccount[v14]));\n    v15 = address(varg1);\n    v16 = address(varg2);\n    assert(_primordialBalanceOf[v15] + _primordialBalanceOf[v16] >= _primordialBalanceOf[v16]);\n    v17 = address(varg2);\n    assert(varg0 <= _primordialBalanceOf[v17]);\n    v18 = address(varg2);\n    _primordialBalanceOf[v18] = _primordialBalanceOf[v17] - varg0;\n    v19 = address(varg1);\n    v20 = varg0 + _primordialBalanceOf[v19];\n    assert(v20 >= _primordialBalanceOf[v19]);\n    v21 = address(varg1);\n    _primordialBalanceOf[v21] = v20;\n    emit PrimordialTransfer(address(varg2), v21, varg0);\n    v22 = address(varg1);\n    v23 = address(varg2);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] >= _primordialBalanceOf[v23]);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] == _primordialBalanceOf[v15] + _primordialBalanceOf[v16]);\n    require(1);\n    return 1;\n}\n\nfunction 0x4c19() private { \n    require(stor_1b_0_19.code.size);\n    v0, v1 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingPrimordialMultiplier').gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v1 + 128] <= 0x100000000);\n    require(v1 + MEM[v1 + 128] + 32 <= v1 + RETURNDATASIZE());\n    require(!((v1 + RETURNDATASIZE() < MEM[v1 + MEM[v1 + 128]] + (v1 + MEM[v1 + 128] + 32)) | (MEM[v1 + MEM[v1 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v2, v3 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingPrimordialMultiplier').gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    RETURNDATACOPY(v3, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v3 + 128] <= 0x100000000);\n    require(v3 + MEM[v3 + 128] + 32 <= v3 + RETURNDATASIZE());\n    require(!((v3 + RETURNDATASIZE() < MEM[v3 + MEM[v3 + 128]] + (v3 + MEM[v3 + 128] + 32)) | (MEM[v3 + MEM[v3 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v4, v5 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingNetworkBonusMultiplier').gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v5 + 128] <= 0x100000000);\n    require(v5 + MEM[v5 + 128] + 32 <= v5 + RETURNDATASIZE());\n    require(!((v5 + RETURNDATASIZE() < MEM[v5 + MEM[v5 + 128]] + (v5 + MEM[v5 + 128] + 32)) | (MEM[v5 + MEM[v5 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v6, v7 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingNetworkBonusMultiplier').gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v7 + 128] <= 0x100000000);\n    require(v7 + MEM[v7 + 128] + 32 <= v7 + RETURNDATASIZE());\n    require(!((v7 + RETURNDATASIZE() < MEM[v7 + MEM[v7 + 128]] + (v7 + MEM[v7 + 128] + 32)) | (MEM[v7 + MEM[v7 + 128]] > 0x100000000)));\n    return MEM[v7], MEM[v5], MEM[v3], MEM[v1];\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction availablePrimordialForSale() public nonPayable { \n    v0 = 0x1597();\n    return v0;\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction 0x510f(uint256 varg0) private { \n    v0 = v1 = 0;\n    assert(_primordialBuyPrice);\n    v2 = 0x56b2(_primordialBuyPrice, v0 / _primordialBuyPrice);\n    assert(v2 <= v0);\n    v3 = v4 = v0 - v2;\n    v3 = v5 = 0;\n    v3 = v6 = 0x48af();\n    if (v1) {\n        v3 = v7 = 20849;\n        v8 = 0x48af();\n        v0 = v9 = v1 > v8;\n    }\n    if (v0) {\n        assert(_primordialBuyPrice);\n        v3 = v10 = v3 / _primordialBuyPrice;\n        v11 = 0x56b2(_primordialBuyPrice, v10);\n        assert(v11 <= v0);\n        v3 = v12 = v0 - v11;\n    }\n    v13 = v14 = 0;\n    assert(v3 + _primordialTotalBought >= _primordialTotalBought);\n    if (v3 + _primordialTotalBought >= 0xc000000000000) {\n        assert(_primordialTotalBought <= 0xc000000000000);\n        v3 = v15 = 0xc000000000000 - _primordialTotalBought;\n        v13 = v16 = 1;\n        v17 = 0x56b2(_primordialBuyPrice, v15);\n        assert(v17 <= v0);\n        v3 = v0 - v17;\n    }\n    return v13, v3, v3;\n}\n\nfunction 0x5240(uint256 varg0, uint256 varg1) private { \n    v0, v1, v2, v3 = 0x4c19();\n    v4, v5, v6, v7 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg1, 0xc000000000000, _primordialTotalBought, v7, v6).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v10, v11 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v12, v13 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v14 = varg1 + _primordialTotalBought;\n    assert(v14 >= _primordialTotalBought);\n    _primordialTotalBought = v14;\n    v15 = 0x5b31(v13, MEM[MEM[64]], varg1, varg0);\n    assert(MEM[MEM[64]] <= v3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v16, v17 = 0x1150d53299abb7de27464d01b626728f5c840229.PERCENTAGE_DIVISOR().gas(msg.gas);\n    require(v16); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] <= v1);\n    assert(v0 + (v1 - MEM[MEM[64]]) >= v1 - MEM[MEM[64]]);\n    v18 = 0x56b2(varg1, v0 + (v1 - MEM[MEM[64]]));\n    assert(v17);\n    if (_aoDevTeam1) {\n        v19 = v20 = 21401;\n        v21 = v22 = _aoDevTeam1;\n        assert(2);\n        v23 = v24 = varg1 >> 1;\n    }\n    assert(2);\n    v25 = 0x5b31(v18 / v17 >> 1, v3 - MEM[MEM[64]], v23, v21);\n    if (_aoDevTeam2) {\n        v19 = v26 = 21453;\n        v21 = v27 = _aoDevTeam2;\n        assert(2);\n        v23 = varg1 >> 1;\n        goto 0x5382;\n    }\n    0x55de(v18 / v17, _theAO);\n    return v15;\n}\n\nfunction setAOSettingAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoSettingAddress = varg0;\n    stor_1b_0_19 = varg0;\n}\n\nfunction 0x53f5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    v2 = varg0 + _balanceOf[v1];\n    assert(v2 >= _balanceOf[v1]);\n    require(v2 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    assert(_balanceOf[v5] + _balanceOf[v6] >= _balanceOf[v6]);\n    v7 = address(varg2);\n    assert(varg0 <= _balanceOf[v7]);\n    v8 = address(varg2);\n    _balanceOf[v8] = _balanceOf[v7] - varg0;\n    v9 = address(varg1);\n    v10 = varg0 + _balanceOf[v9];\n    assert(v10 >= _balanceOf[v9]);\n    v11 = address(varg1);\n    _balanceOf[v11] = v10;\n    emit Transfer(address(varg2), v11, varg0);\n    v12 = address(varg1);\n    v13 = address(varg2);\n    assert(_balanceOf[v12] + _balanceOf[v13] >= _balanceOf[v13]);\n    assert(_balanceOf[v12] + _balanceOf[v13] == _balanceOf[v5] + _balanceOf[v6]);\n    return ;\n}\n\nfunction 0x55de(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _balanceOf[v0];\n    assert(v1 >= _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    v3 = varg0 + _totalSupply;\n    assert(v3 >= _totalSupply);\n    _totalSupply = v3;\n    emit Transfer(0, this, varg0);\n    emit Transfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x56b2(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x56f0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _primordialBalanceOf[v0];\n    assert(v1 >= _primordialBalanceOf[v0]);\n    v2 = address(varg1);\n    _primordialBalanceOf[v2] = v1;\n    v3 = varg0 + _primordialTotalSupply;\n    assert(v3 >= _primordialTotalSupply);\n    _primordialTotalSupply = v3;\n    emit PrimordialTransfer(0, this, varg0);\n    emit PrimordialTransfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction 0x57c4(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    require(varg1 > 0);\n    v0 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createWeightedMultiplierLot(v0, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v4, v5 = _maxMultiplierByAddress.totalLotsByAddress(v3).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 != v5) {\n        return v2;\n    } else {\n        v6 = address(varg2);\n        owner_28[v6] = varg0;\n        return v2;\n    }\n}\n\nfunction 0x5b31(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createPrimordialLot(v0, varg2, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v3], _weightedMultiplierByAddress[v3], varg1, varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = address(varg3);\n    _weightedMultiplierByAddress[v6] = v5;\n    require(_maxMultiplierByAddress.code.size);\n    v7, v8 = _maxMultiplierByAddress.totalLotsByAddress(v6).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 == v8) {\n        v9 = address(varg3);\n        owner_28[v9] = varg1;\n    }\n    0x56f0(varg2, varg3);\n    0x55de(varg0, varg3);\n    return v2;\n}\n\nfunction transferPrimordialBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    v10 = 0x4a27(varg3, varg2, varg1);\n    return v10;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[msg.sender] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction powerOfTen() public nonPayable { \n    return _powerOfTen;\n}\n\nfunction calculateMultiplierAndBonus(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0, v1, v2, v3 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg0, 0xc000000000000, _primordialTotalBought, v3, v2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v6, v7 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return MEM[MEM[64]], MEM[MEM[64]], v9;\n}\n\nfunction buyPrimordialWithAOETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0;\n    v0 = v2 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v3 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v4 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v5 = varg0 > 0;\n    }\n    if (v0) {\n        v6 = 0x32c1();\n        v0 = v7 = v6 > 0;\n    }\n    if (v0) {\n        if (v1) {\n            v0 = v8 = 0;\n            v9 = 0x48af();\n            v0 = v10 = v9 > 7699;\n        }\n        if (!v0) {\n            v0 = v11 = !v0;\n            if (v11) {\n                require(stor_1c_0_19.code.size);\n                v12, v13 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v12); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v14 = _totalRedeemedAOETH < v13;\n            }\n        }\n    }\n    require(v0);\n    v15, v16, v17 = 0x510f(0);\n    require(v17 > 0);\n    if (v15) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v16 <= v0);\n    assert(v0 - v16 + _totalRedeemedAOETH >= _totalRedeemedAOETH);\n    _totalRedeemedAOETH += v0 - v16;\n    require(stor_1c_0_19.code.size);\n    v18, v19 = stor_1c_0_19.whitelistTransferFrom(msg.sender, this, v0 - v16).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v19);\n    v20 = 0x5240(msg.sender, v17);\n    emit BuyPrimordial(msg.sender, v20, 2, v0, v16);\n}\n\nfunction burnPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _primordialBalanceOf[msg.sender]);\n    v0 = 0x42a1(msg.sender);\n    require(v0 >= varg0);\n    v1 = 0x3b1f(varg0, msg.sender);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    assert(varg0 <= _weightedMultiplierByAddress[msg.sender]);\n    _primordialBalanceOf[msg.sender] = _weightedMultiplierByAddress[msg.sender] - varg0;\n    assert(varg0 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg0;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(msg.sender, varg0);\n    return 1;\n}\n\nfunction aoDevTeam1() public nonPayable { \n    return _aoDevTeam1;\n}\n\nfunction primordialStakedBalance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialStakedBalance[varg1];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction stakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg2 == _weightedMultiplierByAddress[varg0]);\n    assert(varg1 <= _primordialBalanceOf[varg0]);\n    _primordialBalanceOf[varg0] = _primordialBalanceOf[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] += varg1;\n    emit PrimordialStake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction aoSettingAddress() public nonPayable { \n    return _aoSettingAddress;\n}\n\nfunction setNameAccountRecoveryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameAccountRecoveryAddress = varg0;\n    stor_7_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x4];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction weightedMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _weightedMultiplierByAddress[varg0];\n}\n\nfunction primordialSellPrice() public nonPayable { \n    return _primordialSellPrice;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction stakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _stakedBalance[varg0] += varg1;\n    emit Stake(varg0, varg1);\n    return 1;\n}\n\nfunction totalRedeemedAOETH() public nonPayable { \n    return _totalRedeemedAOETH;\n}\n\nfunction maxMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_maxMultiplierByAddress.code.size);\n    v0, v1 = _maxMultiplierByAddress.totalLotsByAddress(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        v2 = v3 = owner_28[varg0];\n        goto 0x4e90x93b;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x55de(varg1, varg0);\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction nameTAOPositionAddress() public nonPayable { \n    return _nameTAOPositionAddress;\n}\n\nfunction escrowedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _escrowedBalance[varg0];\n}\n\nfunction setWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _whitelist[varg0] = varg1 | ~0xff & _whitelist[varg0];\n}\n\nfunction primordialBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _primordialBalanceOf[varg0];\n}\n\nfunction setNameTAOPositionAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameTAOPositionAddress = varg0;\n    _transferPrimordialBetweenPublicKeys = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x1];\n}\n\nfunction stakedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _stakedBalance[varg0];\n}\n\nfunction endNetworkExchange() public nonPayable { \n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(!_networkExchangeEnded);\n    _networkExchangeEnded = 1;\n    emit NetworkExchangeEnded();\n}\n\nfunction TOTAL_PRIMORDIAL_FOR_SALE() public nonPayable { \n    return 0xc000000000000;\n}\n\nfunction setNamePublicKeyAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _namePublicKeyAddress = varg0;\n    stor_6_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x3];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction primordialBuyPrice() public nonPayable { \n    return _primordialBuyPrice;\n}\n\nfunction unstakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _stakedBalance[varg0]);\n    assert(varg1 <= _stakedBalance[varg0]);\n    _stakedBalance[varg0] = _stakedBalance[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _stakedBalance[varg0];\n    emit Unstake(varg0, varg1);\n    return 1;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction transferBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    0x53f5(varg3, varg2, varg1);\n    return 1;\n}\n\nfunction primordialTotalSupply() public nonPayable { \n    return _primordialTotalSupply;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction escrowFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _escrowedBalance[varg1] >= _escrowedBalance[varg1]);\n    _escrowedBalance[varg1] += varg2;\n    emit Escrow(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction unescrowFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _escrowedBalance[varg0]);\n    assert(varg1 <= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] = _escrowedBalance[varg0] - varg1;\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _escrowedBalance[varg0];\n    emit Unescrow(varg0, varg1);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelist[varg0];\n}\n\nfunction availablePrimordialForSaleInETH() public nonPayable { \n    v0 = 0x32c1();\n    return v0;\n}\n\nfunction whitelistTransferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction totalEthForPrimordial() public nonPayable { \n    return _totalEthForPrimordial;\n}\n\nfunction nameAccountRecoveryAddress() public nonPayable { \n    return _nameAccountRecoveryAddress;\n}\n\nfunction networkExchangeEnded() public nonPayable { \n    return _networkExchangeEnded;\n}\n\nfunction buy() public payable { \n    require(0 < _buyPrice);\n    assert(_buyPrice);\n    0x53f5(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x53f5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction setPrimordialPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _primordialSellPrice = varg0;\n    _primordialBuyPrice = varg1;\n}\n\nfunction aoDevTeam2() public nonPayable { \n    return _aoDevTeam2;\n}\n\nfunction theAO() public nonPayable { \n    return _theAO;\n}\n\nfunction aoIonLotAddress() public nonPayable { \n    return _aoIonLotAddress;\n}\n\nfunction primordialTotalBought() public nonPayable { \n    return _primordialTotalBought;\n}\n\nfunction transferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _primordialAllowance[msg.sender]);\n    assert(varg2 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg2;\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistBurnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction setAODevTeamAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _aoDevTeam1 = varg0;\n    _aoDevTeam2 = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction transferPrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x4a27(varg1, varg0, msg.sender);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x95d89b41 > v0) {\n            if (0x3a9c7d3d > v0) {\n                if (0x153d9049 > v0) {\n                    if (0x95ea7b3 > v0) {\n                        if (0x32b7006 == v0) {\n                            availablePrimordialForSale();\n                        } else if (0x5fefda7 == v0) {\n                            setPrices(uint256,uint256);\n                        } else if (0x6fd7088 == v0) {\n                            setAOSettingAddress(address);\n                        } else if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x7f09e9a == v0) {\n                            transferPrimordialBetweenPublicKeys(address,address,address,uint256);\n                        }\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0xaa24546 == v0) {\n                        powerOfTen();\n                    } else if (0xac0b31f == v0) {\n                        calculateMultiplierAndBonus(uint256);\n                    } else if (0xde8e272 == v0) {\n                        buyPrimordialWithAOETH(uint256);\n                    } else if (0xe93571b == v0) {\n                        burnPrimordial(uint256);\n                    } else if (0x15227aa7 == v0) {\n                        aoDevTeam1();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x153d9049 == v0) {\n                        primordialStakedBalance(address,uint256);\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x18ff5c51 == v0) {\n                        stakePrimordialFrom(address,uint256,uint256);\n                    } else if (0x1d0138ff == v0) {\n                        aoSettingAddress();\n                    } else if (0x1dfde2bd == v0) {\n                        setNameAccountRecoveryAddress(address);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x281bdaf8 == v0) {\n                    weightedMultiplierByAddress(address);\n                } else if (0x2b687bb9 == v0) {\n                    primordialSellPrice();\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x31a8aeb3 == v0) {\n                    stakeFrom(address,uint256);\n                } else if (0x3480e251 == v0) {\n                    totalRedeemedAOETH();\n                }\n            } else if (0x6aae86c3 > v0) {\n                if (0x4fbd2695 > v0) {\n                    if (0x3a9c7d3d == v0) {\n                        maxMultiplierByAddress(address);\n                    } else if (0x40c10f19 == v0) {\n                        mint(address,uint256);\n                    } else if (0x42966c68 == v0) {\n                        burn(uint256);\n                    } else if (0x4b750334 == v0) {\n                        sellPrice();\n                    } else if (0x4ef033f0 == v0) {\n                        nameTAOPositionAddress();\n                    }\n                } else if (0x4fbd2695 == v0) {\n                    escrowedBalance(address);\n                } else if (0x53d6fd59 == v0) {\n                    setWhitelist(address,bool);\n                } else if (0x57946b8e == v0) {\n                    primordialBalanceOf(address);\n                } else if (0x5cfaf2ef == v0) {\n                    setNameTAOPositionAddress(address);\n                } else if (0x60217267 == v0) {\n                    stakedBalance(address);\n                } else if (0x6a015bbe == v0) {\n                    endNetworkExchange();\n                }\n            } else if (0x79cc6790 > v0) {\n                if (0x6aae86c3 == v0) {\n                    TOTAL_PRIMORDIAL_FOR_SALE();\n                } else if (0x6d9aa034 == v0) {\n                    setNamePublicKeyAddress(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x72d11466 == v0) {\n                    primordialBuyPrice();\n                } else if (0x731a3b06 == v0) {\n                    unstakeFrom(address,uint256);\n                }\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7d9e2a21 == v0) {\n                transferBetweenPublicKeys(address,address,address,uint256);\n            } else if (0x834e9f31 == v0) {\n                primordialTotalSupply();\n            } else if (0x8620410b == v0) {\n                buyPrice();\n            } else if (0x87d4ca93 == v0) {\n                escrowFrom(address,address,uint256);\n            } else if (0x8a066045 == v0) {\n                unescrowFrom(address,uint256);\n            }\n        } else if (0xcf3e194d > v0) {\n            if (0xa99433a6 > v0) {\n                if (0xa2e8760b > v0) {\n                    if (0x95d89b41 == v0) {\n                        symbol();\n                    } else if (0x9b19251a == v0) {\n                        whitelist(address);\n                    } else if (0x9d9b7396 == v0) {\n                        availablePrimordialForSaleInETH();\n                    } else if (0x9eeead7a == v0) {\n                        whitelistTransferPrimordialFrom(address,address,uint256);\n                    } else if (0xa144a3e0 == v0) {\n                        whitelistTransferFrom(address,address,uint256);\n                    }\n                } else if (0xa2e8760b == v0) {\n                    totalEthForPrimordial();\n                } else if (0xa4e5fad2 == v0) {\n                    nameAccountRecoveryAddress();\n                } else if (0xa545a5d1 == v0) {\n                    networkExchangeEnded();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xa9188878 == v0) {\n                    setPrimordialPrices(uint256,uint256);\n                }\n            } else if (0xb1e19d45 > v0) {\n                if (0xa99433a6 == v0) {\n                    aoDevTeam2();\n                } else if (0xa9b6b38e == v0) {\n                    theAO();\n                } else if (0xab13f751 == v0) {\n                    aoIonLotAddress();\n                } else if (0xab7f7706 == v0) {\n                    primordialTotalBought();\n                } else if (0xadc933cf == v0) {\n                    transferPrimordialFrom(address,address,uint256);\n                }\n            } else if (0xb1e19d45 == v0) {\n                whitelistBurnFrom(address,uint256);\n            } else if (0xb24626e9 == v0) {\n                setAODevTeamAddresses(address,address);\n            } else if (0xb414d4b6 == v0) {\n                frozenAccount(address);\n            } else if (0xb811ae7f == v0) {\n                transferPrimordial(address,uint256);\n            } else if (0xc3c1ac47 == v0) {\n                burnPrimordialFrom(address,uint256);\n            } else if (0xcae9ca51 == v0) {\n                approveAndCall(address,uint256,bytes);\n            }\n        } else if (0xe7c50185 > v0) {\n            if (0xd6830af3 > v0) {\n                if (0xcf3e194d == v0) {\n                    calculateMultiplierAfterConversion(address,uint256);\n                } else if (0xd1e5a552 == v0) {\n                    primordialAllowance(address,address);\n                } else if (0xd3183864 == v0) {\n                    calculateMultiplierAfterBurn(address,uint256);\n                } else if (0xd569aa25 == v0) {\n                    setAOETHAddress(address);\n                } else if (0xd64468bf == v0) {\n                    setAOIonLotAddress(address);\n                }\n            } else if (0xd6830af3 == v0) {\n                setSettingTAOId(address);\n            } else if (0xd6c9e189 == v0) {\n                mintEscrow(address,uint256);\n            } else if (0xd8ce52d1 == v0) {\n                namePublicKeyAddress();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe4849b32 == v0) {\n                sell(uint256);\n            } else if (0xe724529c == v0) {\n                freezeAccount(address,bool);\n            }\n        } else if (0xf81eb76d > v0) {\n            if (0xe7c50185 == v0) {\n                settingTAOId();\n            } else if (0xe9bb84c2 == v0) {\n                transferEth(address,uint256);\n            } else if (0xecbbd1ca == v0) {\n                calculateMaximumBurnAmount(address);\n            } else if (0xede5e884 == v0) {\n                approvePrimordialAndCall(address,uint256,bytes);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            }\n        } else if (0xf81eb76d == v0) {\n            unstakePrimordialFrom(address,uint256,uint256);\n        } else if (0xf9f43634 == v0) {\n            buyPrimordial();\n        } else if (0xfaaad91d == v0) {\n            convertToPrimordial(uint256);\n        } else if (0xfb6ff161 == v0) {\n            availableETH();\n        } else if (0xfdb52e86 == v0) {\n            aoethAddress();\n        } else if (0xfff17e9e == v0) {\n            approvePrimordial(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 09:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x8]\nuint256[] _symbol; // STORAGE[0x9]\nuint256 _totalSupply; // STORAGE[0xb]\nuint256 _powerOfTen; // STORAGE[0xc]\nuint256 _sellPrice; // STORAGE[0xd]\nuint256 _buyPrice; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _stakedBalance; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _escrowedBalance; // STORAGE[0x13]\nuint160 _theAO; // STORAGE[0x0] bytes 0 to 19\nuint256 _primordialTotalSupply; // STORAGE[0x1d]\nuint256 _primordialTotalBought; // STORAGE[0x1e]\nuint256 _primordialSellPrice; // STORAGE[0x1f]\nuint256 _primordialBuyPrice; // STORAGE[0x20]\nuint256 _totalEthForPrimordial; // STORAGE[0x21]\nuint256 _totalRedeemedAOETH; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _primordialBalanceOf; // STORAGE[0x23]\nmapping (uint256 => [uint256]) _primordialAllowance; // STORAGE[0x24]\nmapping (uint256 => [uint256]) _primordialStakedBalance; // STORAGE[0x25]\nmapping (uint256 => [uint256]) _weightedMultiplierByAddress; // STORAGE[0x27]\nmapping (uint256 => [uint256]) owner_28; // STORAGE[0x28]\nuint8 _decimals; // STORAGE[0xa] bytes 0 to 0\nuint160 _nameTAOPositionAddress; // STORAGE[0x1] bytes 0 to 19\nuint8 _networkExchangeEnded; // STORAGE[0x26] bytes 0 to 0\nuint160 _namePublicKeyAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _nameAccountRecoveryAddress; // STORAGE[0x4] bytes 0 to 19\naddress _transferPrimordialBetweenPublicKeys; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\nuint160 _aoIonLotAddress; // STORAGE[0x14] bytes 0 to 19\nuint160 _settingTAOId; // STORAGE[0x15] bytes 0 to 19\nuint160 _aoSettingAddress; // STORAGE[0x16] bytes 0 to 19\nuint160 _aoethAddress; // STORAGE[0x17] bytes 0 to 19\nuint160 _aoDevTeam1; // STORAGE[0x18] bytes 0 to 19\nuint160 _aoDevTeam2; // STORAGE[0x19] bytes 0 to 19\naddress _maxMultiplierByAddress; // STORAGE[0x1a] bytes 0 to 19\naddress stor_1b_0_19; // STORAGE[0x1b] bytes 0 to 19\naddress stor_1c_0_19; // STORAGE[0x1c] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nNetworkExchangeEnded();\nBuyPrimordial(address, bytes32, uint8, uint256, uint256);\nPrimordialBurn(address, uint256);\nPrimordialStake(address, uint256, uint256);\nStake(address, uint256);\nBurn(address, uint256);\nUnstake(address, uint256);\nEscrow(address, address, uint256);\nUnescrow(address, uint256);\nFrozenFunds(address, bool);\nPrimordialUnstake(address, uint256, uint256);\nPrimordialApproval(address, address, uint256);\nTransfer(address, address, uint256);\nPrimordialTransfer(address, address, uint256);\n\nfunction burnPrimordialFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg1 <= _primordialAllowance[msg.sender]);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    v1 = 0x3b1f(varg1, varg0);\n    _weightedMultiplierByAddress[varg0] = v1;\n    assert(varg1 <= _weightedMultiplierByAddress[varg0]);\n    _primordialBalanceOf[varg0] = _weightedMultiplierByAddress[varg0] - varg1;\n    assert(varg1 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg1;\n    assert(varg1 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg1;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(varg0, varg1, _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction calculateMultiplierAfterConversion(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction primordialAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialAllowance[varg1];\n}\n\nfunction calculateMultiplierAfterBurn(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x42a1(varg0);\n    require(v0 >= varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction setAOETHAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoethAddress = varg0;\n    stor_1c_0_19 = varg0;\n}\n\nfunction setAOIonLotAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoIonLotAddress = varg0;\n    _maxMultiplierByAddress = varg0;\n}\n\nfunction setSettingTAOId(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.isTAO(varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    _settingTAOId = varg0;\n}\n\nfunction mintEscrow(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] += varg1;\n    assert(varg1 + _totalSupply >= _totalSupply);\n    _totalSupply += varg1;\n    emit Escrow(this, varg0, varg1);\n    return 1;\n}\n\nfunction namePublicKeyAddress() public nonPayable { \n    return _namePublicKeyAddress;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0 < _sellPrice);\n    v0 = 0x56b2(_sellPrice, varg0);\n    require((address(this)).balance >= v0);\n    0x53f5(varg0, this, msg.sender);\n    v1 = 0x56b2(_sellPrice, varg0);\n    v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction settingTAOId() public nonPayable { \n    return _settingTAOId;\n}\n\nfunction transferEth(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    v2 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction calculateMaximumBurnAmount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[varg0], _weightedMultiplierByAddress[varg0], _weightedMultiplierByAddress[varg0]).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction approvePrimordialAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    v1 = v2 = 0;\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v4 + v3.data] = MEM[v4 + v0.data];\n            v4 += 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, this, v3).gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _theAO = varg0;\n}\n\nfunction unstakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialStakedBalance[varg0]);\n    assert(varg1 <= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] = _primordialStakedBalance[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialBalanceOf[varg0] = varg1 + _primordialStakedBalance[varg0];\n    emit PrimordialUnstake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction buyPrimordial() public payable { \n    v0 = v1 = msg.value;\n    v0 = v2 = 1;\n    v0 = v3 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v4 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v5 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v6 = v1 > 0;\n    }\n    if (v0) {\n        v7 = 0x32c1();\n        v0 = v8 = v7 > 0;\n    }\n    if (v0) {\n        if (v2) {\n            v0 = v9 = 0;\n            v10 = 0x48af();\n            v0 = v11 = v10 > 17903;\n        }\n        if (!v0) {\n            v0 = v12 = !v0;\n            if (v12) {\n                require(stor_1c_0_19.code.size);\n                v13, v14 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v13); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v15 = _totalRedeemedAOETH < v14;\n            }\n        }\n    }\n    require(v0);\n    v16, v17, v18 = 0x510f(1);\n    require(v18 > 0);\n    if (v16) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v17 <= msg.value);\n    assert(msg.value - v17 + _totalEthForPrimordial >= _totalEthForPrimordial);\n    _totalEthForPrimordial += msg.value - v17;\n    v19 = 0x5240(msg.sender, v18);\n    emit BuyPrimordial(msg.sender, v19, 1, msg.value, v17);\n    if (v17 > 0) {\n        v20 = msg.sender.call().value(v17).gas(2300 * !v17);\n        require(v20); // checks call status, propagates error data on error\n    }\n}\n\nfunction convertToPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterConversion(_primordialBalanceOf[msg.sender], _weightedMultiplierByAddress[msg.sender], varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    0x56f0(varg0, msg.sender);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createConvertLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    return 1;\n}\n\nfunction availableETH() public nonPayable { \n    v0 = 0x48af();\n    return v0;\n}\n\nfunction aoethAddress() public nonPayable { \n    return _aoethAddress;\n}\n\nfunction approvePrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _primordialAllowance[msg.sender] = varg1;\n    emit PrimordialApproval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x1597() private { \n    assert(_primordialTotalBought <= 0xc000000000000);\n    return 0xc000000000000 - _primordialTotalBought;\n}\n\nfunction 0x32c1() private { \n    v0 = 0x1597();\n    v1 = 0x56b2(_primordialBuyPrice, v0);\n    return v1;\n}\n\nfunction 0x3b1f(uint256 varg0, uint256 varg1) private { \n    v0 = 0x42a1(varg1);\n    require(v0 >= varg0);\n    v1 = address(varg1);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v2, v3 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMultiplierAfterBurn(_primordialBalanceOf[v1], _weightedMultiplierByAddress[v1], varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v3;\n}\n\nfunction 0x42a1(uint256 varg0) private { \n    v0 = address(varg0);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v1, v2 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateMaximumBurnAmount(_primordialBalanceOf[v0], _weightedMultiplierByAddress[v0], _weightedMultiplierByAddress[v0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v2;\n}\n\nfunction 0x48af() private { \n    v0 = v1 = 0;\n    v2 = 0x32c1();\n    if (v2 <= v1) {\n        v3 = v4 = 0;\n    } else {\n        v0 = v5 = 0;\n        v0 = v6 = 18792;\n        v0 = v7 = 18772;\n        v3 = v8 = _totalRedeemedAOETH;\n        require(stor_1c_0_19.code.size);\n        v9, v10 = stor_1c_0_19.totalSupply().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        while (v3 > v10) {\n            v3 = v10 - v3;\n            goto {'0x4968', '0x4954'};\n            v10 = v11 = 0x32c1();\n        }\n        throw();\n        v12 = 0x1597();\n        v13 = v14 = 1 == v12;\n        if (v14) {\n            v13 = v15 = v3 < _primordialBuyPrice;\n        }\n        if (v13) {\n            v3 = v16 = _primordialBuyPrice;\n        }\n    }\n    return v3;\n}\n\nfunction 0x4a27(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = 0x57c4(_weightedMultiplierByAddress[v0], varg0, varg1);\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3, v4 = _maxMultiplierByAddress.lotById(v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 128);\n    require(address(varg1) == address(v4));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v7, v8 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v5], _weightedMultiplierByAddress[v6], varg0).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v9 = address(varg1);\n    _weightedMultiplierByAddress[v9] = v8;\n    require(address(varg1));\n    v10 = address(varg2);\n    require(varg0 <= _primordialBalanceOf[v10]);\n    v11 = address(varg1);\n    v12 = varg0 + _primordialBalanceOf[v11];\n    assert(v12 >= _primordialBalanceOf[v11]);\n    require(v12 >= _primordialBalanceOf[v11]);\n    v13 = address(varg2);\n    require(!(0xff & _frozenAccount[v13]));\n    v14 = address(varg1);\n    require(!(0xff & _frozenAccount[v14]));\n    v15 = address(varg1);\n    v16 = address(varg2);\n    assert(_primordialBalanceOf[v15] + _primordialBalanceOf[v16] >= _primordialBalanceOf[v16]);\n    v17 = address(varg2);\n    assert(varg0 <= _primordialBalanceOf[v17]);\n    v18 = address(varg2);\n    _primordialBalanceOf[v18] = _primordialBalanceOf[v17] - varg0;\n    v19 = address(varg1);\n    v20 = varg0 + _primordialBalanceOf[v19];\n    assert(v20 >= _primordialBalanceOf[v19]);\n    v21 = address(varg1);\n    _primordialBalanceOf[v21] = v20;\n    emit PrimordialTransfer(address(varg2), v21, varg0);\n    v22 = address(varg1);\n    v23 = address(varg2);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] >= _primordialBalanceOf[v23]);\n    assert(_primordialBalanceOf[v22] + _primordialBalanceOf[v23] == _primordialBalanceOf[v15] + _primordialBalanceOf[v16]);\n    require(1);\n    return 1;\n}\n\nfunction 0x4c19() private { \n    require(stor_1b_0_19.code.size);\n    v0, v1 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingPrimordialMultiplier').gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v1 + 128] <= 0x100000000);\n    require(v1 + MEM[v1 + 128] + 32 <= v1 + RETURNDATASIZE());\n    require(!((v1 + RETURNDATASIZE() < MEM[v1 + MEM[v1 + 128]] + (v1 + MEM[v1 + 128] + 32)) | (MEM[v1 + MEM[v1 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v2, v3 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingPrimordialMultiplier').gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    RETURNDATACOPY(v3, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v3 + 128] <= 0x100000000);\n    require(v3 + MEM[v3 + 128] + 32 <= v3 + RETURNDATASIZE());\n    require(!((v3 + RETURNDATASIZE() < MEM[v3 + MEM[v3 + 128]] + (v3 + MEM[v3 + 128] + 32)) | (MEM[v3 + MEM[v3 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v4, v5 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'startingNetworkBonusMultiplier').gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v5 + 128] <= 0x100000000);\n    require(v5 + MEM[v5 + 128] + 32 <= v5 + RETURNDATASIZE());\n    require(!((v5 + RETURNDATASIZE() < MEM[v5 + MEM[v5 + 128]] + (v5 + MEM[v5 + 128] + 32)) | (MEM[v5 + MEM[v5 + 128]] > 0x100000000)));\n    require(stor_1b_0_19.code.size);\n    v6, v7 = stor_1b_0_19.getSettingValuesByTAOName(_settingTAOId, 'endingNetworkBonusMultiplier').gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 160);\n    require(MEM[v7 + 128] <= 0x100000000);\n    require(v7 + MEM[v7 + 128] + 32 <= v7 + RETURNDATASIZE());\n    require(!((v7 + RETURNDATASIZE() < MEM[v7 + MEM[v7 + 128]] + (v7 + MEM[v7 + 128] + 32)) | (MEM[v7 + MEM[v7 + 128]] > 0x100000000)));\n    return MEM[v7], MEM[v5], MEM[v3], MEM[v1];\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction availablePrimordialForSale() public nonPayable { \n    v0 = 0x1597();\n    return v0;\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction 0x510f(uint256 varg0) private { \n    v0 = v1 = 0;\n    assert(_primordialBuyPrice);\n    v2 = 0x56b2(_primordialBuyPrice, v0 / _primordialBuyPrice);\n    assert(v2 <= v0);\n    v3 = v4 = v0 - v2;\n    v3 = v5 = 0;\n    v3 = v6 = 0x48af();\n    if (v1) {\n        v3 = v7 = 20849;\n        v8 = 0x48af();\n        v0 = v9 = v1 > v8;\n    }\n    if (v0) {\n        assert(_primordialBuyPrice);\n        v3 = v10 = v3 / _primordialBuyPrice;\n        v11 = 0x56b2(_primordialBuyPrice, v10);\n        assert(v11 <= v0);\n        v3 = v12 = v0 - v11;\n    }\n    v13 = v14 = 0;\n    assert(v3 + _primordialTotalBought >= _primordialTotalBought);\n    if (v3 + _primordialTotalBought >= 0xc000000000000) {\n        assert(_primordialTotalBought <= 0xc000000000000);\n        v3 = v15 = 0xc000000000000 - _primordialTotalBought;\n        v13 = v16 = 1;\n        v17 = 0x56b2(_primordialBuyPrice, v15);\n        assert(v17 <= v0);\n        v3 = v0 - v17;\n    }\n    return v13, v3, v3;\n}\n\nfunction 0x5240(uint256 varg0, uint256 varg1) private { \n    v0, v1, v2, v3 = 0x4c19();\n    v4, v5, v6, v7 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg1, 0xc000000000000, _primordialTotalBought, v7, v6).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v10, v11 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v12, v13 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg1, 0xc000000000000, _primordialTotalBought, v5, v4).gas(msg.gas);\n    require(v12); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v14 = varg1 + _primordialTotalBought;\n    assert(v14 >= _primordialTotalBought);\n    _primordialTotalBought = v14;\n    v15 = 0x5b31(v13, MEM[MEM[64]], varg1, varg0);\n    assert(MEM[MEM[64]] <= v3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v16, v17 = 0x1150d53299abb7de27464d01b626728f5c840229.PERCENTAGE_DIVISOR().gas(msg.gas);\n    require(v16); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] <= v1);\n    assert(v0 + (v1 - MEM[MEM[64]]) >= v1 - MEM[MEM[64]]);\n    v18 = 0x56b2(varg1, v0 + (v1 - MEM[MEM[64]]));\n    assert(v17);\n    if (_aoDevTeam1) {\n        v19 = v20 = 21401;\n        v21 = v22 = _aoDevTeam1;\n        assert(2);\n        v23 = v24 = varg1 >> 1;\n    }\n    assert(2);\n    v25 = 0x5b31(v18 / v17 >> 1, v3 - MEM[MEM[64]], v23, v21);\n    if (_aoDevTeam2) {\n        v19 = v26 = 21453;\n        v21 = v27 = _aoDevTeam2;\n        assert(2);\n        v23 = varg1 >> 1;\n        goto 0x5382;\n    }\n    0x55de(v18 / v17, _theAO);\n    return v15;\n}\n\nfunction setAOSettingAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _aoSettingAddress = varg0;\n    stor_1b_0_19 = varg0;\n}\n\nfunction 0x53f5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    v2 = varg0 + _balanceOf[v1];\n    assert(v2 >= _balanceOf[v1]);\n    require(v2 >= _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg1);\n    v6 = address(varg2);\n    assert(_balanceOf[v5] + _balanceOf[v6] >= _balanceOf[v6]);\n    v7 = address(varg2);\n    assert(varg0 <= _balanceOf[v7]);\n    v8 = address(varg2);\n    _balanceOf[v8] = _balanceOf[v7] - varg0;\n    v9 = address(varg1);\n    v10 = varg0 + _balanceOf[v9];\n    assert(v10 >= _balanceOf[v9]);\n    v11 = address(varg1);\n    _balanceOf[v11] = v10;\n    emit Transfer(address(varg2), v11, varg0);\n    v12 = address(varg1);\n    v13 = address(varg2);\n    assert(_balanceOf[v12] + _balanceOf[v13] >= _balanceOf[v13]);\n    assert(_balanceOf[v12] + _balanceOf[v13] == _balanceOf[v5] + _balanceOf[v6]);\n    return ;\n}\n\nfunction 0x55de(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _balanceOf[v0];\n    assert(v1 >= _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    v3 = varg0 + _totalSupply;\n    assert(v3 >= _totalSupply);\n    _totalSupply = v3;\n    emit Transfer(0, this, varg0);\n    emit Transfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x56b2(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x56f0(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    v1 = varg0 + _primordialBalanceOf[v0];\n    assert(v1 >= _primordialBalanceOf[v0]);\n    v2 = address(varg1);\n    _primordialBalanceOf[v2] = v1;\n    v3 = varg0 + _primordialTotalSupply;\n    assert(v3 >= _primordialTotalSupply);\n    _primordialTotalSupply = v3;\n    emit PrimordialTransfer(0, this, varg0);\n    emit PrimordialTransfer(this, address(varg1), varg0);\n    return ;\n}\n\nfunction 0x57c4(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2));\n    require(varg1 > 0);\n    v0 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createWeightedMultiplierLot(v0, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg2);\n    require(_maxMultiplierByAddress.code.size);\n    v4, v5 = _maxMultiplierByAddress.totalLotsByAddress(v3).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 != v5) {\n        return v2;\n    } else {\n        v6 = address(varg2);\n        owner_28[v6] = varg0;\n        return v2;\n    }\n}\n\nfunction 0x5b31(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3);\n    require(_maxMultiplierByAddress.code.size);\n    v1, v2 = _maxMultiplierByAddress.createPrimordialLot(v0, varg2, varg1, varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateWeightedMultiplier(_weightedMultiplierByAddress[v3], _weightedMultiplierByAddress[v3], varg1, varg2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v6 = address(varg3);\n    _weightedMultiplierByAddress[v6] = v5;\n    require(_maxMultiplierByAddress.code.size);\n    v7, v8 = _maxMultiplierByAddress.totalLotsByAddress(v6).gas(msg.gas);\n    require(v7); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (1 == v8) {\n        v9 = address(varg3);\n        owner_28[v9] = varg1;\n    }\n    0x56f0(varg2, varg3);\n    0x55de(varg0, varg3);\n    return v2;\n}\n\nfunction transferPrimordialBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    v10 = 0x4a27(varg3, varg2, varg1);\n    return v10;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[msg.sender] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction powerOfTen() public nonPayable { \n    return _powerOfTen;\n}\n\nfunction calculateMultiplierAndBonus(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0, v1, v2, v3 = 0x4c19();\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v4, v5 = 0x1150d53299abb7de27464d01b626728f5c840229.calculatePrimordialMultiplier(varg0, 0xc000000000000, _primordialTotalBought, v3, v2).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v6, v7 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusPercentage(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v8, v9 = 0x1150d53299abb7de27464d01b626728f5c840229.calculateNetworkBonusAmount(varg0, 0xc000000000000, _primordialTotalBought, v1, v0).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return MEM[MEM[64]], MEM[MEM[64]], v9;\n}\n\nfunction buyPrimordialWithAOETH(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0;\n    v0 = v2 = !_networkExchangeEnded;\n    if (!_networkExchangeEnded) {\n        v0 = v3 = _primordialTotalBought < 0xc000000000000;\n    }\n    if (v0) {\n        v0 = v4 = _primordialBuyPrice > 0;\n    }\n    if (v0) {\n        v0 = v5 = varg0 > 0;\n    }\n    if (v0) {\n        v6 = 0x32c1();\n        v0 = v7 = v6 > 0;\n    }\n    if (v0) {\n        if (v1) {\n            v0 = v8 = 0;\n            v9 = 0x48af();\n            v0 = v10 = v9 > 7699;\n        }\n        if (!v0) {\n            v0 = v11 = !v0;\n            if (v11) {\n                require(stor_1c_0_19.code.size);\n                v12, v13 = stor_1c_0_19.totalSupply().gas(msg.gas);\n                require(v12); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                v0 = v14 = _totalRedeemedAOETH < v13;\n            }\n        }\n    }\n    require(v0);\n    v15, v16, v17 = 0x510f(0);\n    require(v17 > 0);\n    if (v15) {\n        _networkExchangeEnded = 1;\n        emit NetworkExchangeEnded();\n    }\n    assert(v16 <= v0);\n    assert(v0 - v16 + _totalRedeemedAOETH >= _totalRedeemedAOETH);\n    _totalRedeemedAOETH += v0 - v16;\n    require(stor_1c_0_19.code.size);\n    v18, v19 = stor_1c_0_19.whitelistTransferFrom(msg.sender, this, v0 - v16).gas(msg.gas);\n    require(v18); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v19);\n    v20 = 0x5240(msg.sender, v17);\n    emit BuyPrimordial(msg.sender, v20, 2, v0, v16);\n}\n\nfunction burnPrimordial(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _primordialBalanceOf[msg.sender]);\n    v0 = 0x42a1(msg.sender);\n    require(v0 >= varg0);\n    v1 = 0x3b1f(varg0, msg.sender);\n    _weightedMultiplierByAddress[msg.sender] = v1;\n    assert(varg0 <= _weightedMultiplierByAddress[msg.sender]);\n    _primordialBalanceOf[msg.sender] = _weightedMultiplierByAddress[msg.sender] - varg0;\n    assert(varg0 <= _primordialTotalSupply);\n    _primordialTotalSupply = _primordialTotalSupply - varg0;\n    require(_maxMultiplierByAddress.code.size);\n    v2, v3 = _maxMultiplierByAddress.createBurnLot(msg.sender, varg0, _weightedMultiplierByAddress[msg.sender]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    emit PrimordialBurn(msg.sender, varg0);\n    return 1;\n}\n\nfunction aoDevTeam1() public nonPayable { \n    return _aoDevTeam1;\n}\n\nfunction primordialStakedBalance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _primordialStakedBalance[varg1];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction stakePrimordialFrom(address varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _primordialBalanceOf[varg0]);\n    require(varg2 == _weightedMultiplierByAddress[varg0]);\n    assert(varg1 <= _primordialBalanceOf[varg0]);\n    _primordialBalanceOf[varg0] = _primordialBalanceOf[varg0] - varg1;\n    assert(varg1 + _primordialStakedBalance[varg0] >= _primordialStakedBalance[varg0]);\n    _primordialStakedBalance[varg0] += varg1;\n    emit PrimordialStake(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction aoSettingAddress() public nonPayable { \n    return _aoSettingAddress;\n}\n\nfunction setNameAccountRecoveryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameAccountRecoveryAddress = varg0;\n    stor_7_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x4];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction weightedMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _weightedMultiplierByAddress[varg0];\n}\n\nfunction primordialSellPrice() public nonPayable { \n    return _primordialSellPrice;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction stakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _stakedBalance[varg0] += varg1;\n    emit Stake(varg0, varg1);\n    return 1;\n}\n\nfunction totalRedeemedAOETH() public nonPayable { \n    return _totalRedeemedAOETH;\n}\n\nfunction maxMultiplierByAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_maxMultiplierByAddress.code.size);\n    v0, v1 = _maxMultiplierByAddress.totalLotsByAddress(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    if (v1 > 0) {\n        v2 = v3 = owner_28[varg0];\n        goto 0x4e90x93b;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction mint(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x55de(varg1, varg0);\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction nameTAOPositionAddress() public nonPayable { \n    return _nameTAOPositionAddress;\n}\n\nfunction escrowedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _escrowedBalance[varg0];\n}\n\nfunction setWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _whitelist[varg0] = varg1 | ~0xff & _whitelist[varg0];\n}\n\nfunction primordialBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _primordialBalanceOf[varg0];\n}\n\nfunction setNameTAOPositionAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _nameTAOPositionAddress = varg0;\n    _transferPrimordialBetweenPublicKeys = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x1];\n}\n\nfunction stakedBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _stakedBalance[varg0];\n}\n\nfunction endNetworkExchange() public nonPayable { \n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(!_networkExchangeEnded);\n    _networkExchangeEnded = 1;\n    emit NetworkExchangeEnded();\n}\n\nfunction TOTAL_PRIMORDIAL_FOR_SALE() public nonPayable { \n    return 0xc000000000000;\n}\n\nfunction setNamePublicKeyAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(varg0);\n    _namePublicKeyAddress = varg0;\n    stor_6_0_19 = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x3];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction primordialBuyPrice() public nonPayable { \n    return _primordialBuyPrice;\n}\n\nfunction unstakeFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _stakedBalance[varg0]);\n    assert(varg1 <= _stakedBalance[varg0]);\n    _stakedBalance[varg0] = _stakedBalance[varg0] - varg1;\n    assert(varg1 + _stakedBalance[varg0] >= _stakedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _stakedBalance[varg0];\n    emit Unstake(varg0, varg1);\n    return 1;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction transferBetweenPublicKeys(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isName(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    require(_transferPrimordialBetweenPublicKeys.code.size);\n    v2, v3 = _transferPrimordialBetweenPublicKeys.senderIsAdvocate(msg.sender, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v3);\n    require(stor_7_0_19.code.size);\n    v4, v5 = stor_7_0_19.isCompromised(varg0).gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v5);\n    require(stor_6_0_19.code.size);\n    v6, v7 = stor_6_0_19.isKeyExist(varg0, varg1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v7);\n    require(stor_6_0_19.code.size);\n    v8, v9 = stor_6_0_19.isKeyExist(varg0, varg2).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v9);\n    0x53f5(varg3, varg2, varg1);\n    return 1;\n}\n\nfunction primordialTotalSupply() public nonPayable { \n    return _primordialTotalSupply;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction escrowFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg2 <= _balanceOf[varg0]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _escrowedBalance[varg1] >= _escrowedBalance[varg1]);\n    _escrowedBalance[varg1] += varg2;\n    emit Escrow(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction unescrowFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _escrowedBalance[varg0]);\n    assert(varg1 <= _escrowedBalance[varg0]);\n    _escrowedBalance[varg0] = _escrowedBalance[varg0] - varg1;\n    assert(varg1 + _escrowedBalance[varg0] >= _escrowedBalance[varg0]);\n    _balanceOf[varg0] = varg1 + _escrowedBalance[varg0];\n    emit Unescrow(varg0, varg1);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelist[varg0];\n}\n\nfunction availablePrimordialForSaleInETH() public nonPayable { \n    v0 = 0x32c1();\n    return v0;\n}\n\nfunction whitelistTransferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    0x53f5(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction totalEthForPrimordial() public nonPayable { \n    return _totalEthForPrimordial;\n}\n\nfunction nameAccountRecoveryAddress() public nonPayable { \n    return _nameAccountRecoveryAddress;\n}\n\nfunction networkExchangeEnded() public nonPayable { \n    return _networkExchangeEnded;\n}\n\nfunction buy() public payable { \n    require(0 < _buyPrice);\n    assert(_buyPrice);\n    0x53f5(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x53f5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction setPrimordialPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _primordialSellPrice = varg0;\n    _primordialBuyPrice = varg1;\n}\n\nfunction aoDevTeam2() public nonPayable { \n    return _aoDevTeam2;\n}\n\nfunction theAO() public nonPayable { \n    return _theAO;\n}\n\nfunction aoIonLotAddress() public nonPayable { \n    return _aoIonLotAddress;\n}\n\nfunction primordialTotalBought() public nonPayable { \n    return _primordialTotalBought;\n}\n\nfunction transferPrimordialFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _primordialAllowance[msg.sender]);\n    assert(varg2 <= _primordialAllowance[msg.sender]);\n    _primordialAllowance[msg.sender] = _primordialAllowance[msg.sender] - varg2;\n    v0 = 0x4a27(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction whitelistBurnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(1 == 0xff & _whitelist[msg.sender]);\n    require(varg1 <= _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction setAODevTeamAddresses(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0x1150d53299abb7de27464d01b626728f5c840229.code.size);\n    v0, v1 = 0x1150d53299abb7de27464d01b626728f5c840229.isTheAO(msg.sender, _theAO, _nameTAOPositionAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    _aoDevTeam1 = varg0;\n    _aoDevTeam2 = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction transferPrimordial(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = 0x4a27(varg1, varg0, msg.sender);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x95d89b41 > v0) {\n            if (0x3a9c7d3d > v0) {\n                if (0x153d9049 > v0) {\n                    if (0x95ea7b3 > v0) {\n                        if (0x32b7006 == v0) {\n                            availablePrimordialForSale();\n                        } else if (0x5fefda7 == v0) {\n                            setPrices(uint256,uint256);\n                        } else if (0x6fd7088 == v0) {\n                            setAOSettingAddress(address);\n                        } else if (0x6fdde03 == v0) {\n                            name();\n                        } else if (0x7f09e9a == v0) {\n                            transferPrimordialBetweenPublicKeys(address,address,address,uint256);\n                        }\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    } else if (0xaa24546 == v0) {\n                        powerOfTen();\n                    } else if (0xac0b31f == v0) {\n                        calculateMultiplierAndBonus(uint256);\n                    } else if (0xde8e272 == v0) {\n                        buyPrimordialWithAOETH(uint256);\n                    } else if (0xe93571b == v0) {\n                        burnPrimordial(uint256);\n                    } else if (0x15227aa7 == v0) {\n                        aoDevTeam1();\n                    }\n                } else if (0x23b872dd > v0) {\n                    if (0x153d9049 == v0) {\n                        primordialStakedBalance(address,uint256);\n                    } else if (0x18160ddd == v0) {\n                        totalSupply();\n                    } else if (0x18ff5c51 == v0) {\n                        stakePrimordialFrom(address,uint256,uint256);\n                    } else if (0x1d0138ff == v0) {\n                        aoSettingAddress();\n                    } else if (0x1dfde2bd == v0) {\n                        setNameAccountRecoveryAddress(address);\n                    }\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x281bdaf8 == v0) {\n                    weightedMultiplierByAddress(address);\n                } else if (0x2b687bb9 == v0) {\n                    primordialSellPrice();\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x31a8aeb3 == v0) {\n                    stakeFrom(address,uint256);\n                } else if (0x3480e251 == v0) {\n                    totalRedeemedAOETH();\n                }\n            } else if (0x6aae86c3 > v0) {\n                if (0x4fbd2695 > v0) {\n                    if (0x3a9c7d3d == v0) {\n                        maxMultiplierByAddress(address);\n                    } else if (0x40c10f19 == v0) {\n                        mint(address,uint256);\n                    } else if (0x42966c68 == v0) {\n                        burn(uint256);\n                    } else if (0x4b750334 == v0) {\n                        sellPrice();\n                    } else if (0x4ef033f0 == v0) {\n                        nameTAOPositionAddress();\n                    }\n                } else if (0x4fbd2695 == v0) {\n                    escrowedBalance(address);\n                } else if (0x53d6fd59 == v0) {\n                    setWhitelist(address,bool);\n                } else if (0x57946b8e == v0) {\n                    primordialBalanceOf(address);\n                } else if (0x5cfaf2ef == v0) {\n                    setNameTAOPositionAddress(address);\n                } else if (0x60217267 == v0) {\n                    stakedBalance(address);\n                } else if (0x6a015bbe == v0) {\n                    endNetworkExchange();\n                }\n            } else if (0x79cc6790 > v0) {\n                if (0x6aae86c3 == v0) {\n                    TOTAL_PRIMORDIAL_FOR_SALE();\n                } else if (0x6d9aa034 == v0) {\n                    setNamePublicKeyAddress(address);\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x72d11466 == v0) {\n                    primordialBuyPrice();\n                } else if (0x731a3b06 == v0) {\n                    unstakeFrom(address,uint256);\n                }\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7d9e2a21 == v0) {\n                transferBetweenPublicKeys(address,address,address,uint256);\n            } else if (0x834e9f31 == v0) {\n                primordialTotalSupply();\n            } else if (0x8620410b == v0) {\n                buyPrice();\n            } else if (0x87d4ca93 == v0) {\n                escrowFrom(address,address,uint256);\n            } else if (0x8a066045 == v0) {\n                unescrowFrom(address,uint256);\n            }\n        } else if (0xcf3e194d > v0) {\n            if (0xa99433a6 > v0) {\n                if (0xa2e8760b > v0) {\n                    if (0x95d89b41 == v0) {\n                        symbol();\n                    } else if (0x9b19251a == v0) {\n                        whitelist(address);\n                    } else if (0x9d9b7396 == v0) {\n                        availablePrimordialForSaleInETH();\n                    } else if (0x9eeead7a == v0) {\n                        whitelistTransferPrimordialFrom(address,address,uint256);\n                    } else if (0xa144a3e0 == v0) {\n                        whitelistTransferFrom(address,address,uint256);\n                    }\n                } else if (0xa2e8760b == v0) {\n                    totalEthForPrimordial();\n                } else if (0xa4e5fad2 == v0) {\n                    nameAccountRecoveryAddress();\n                } else if (0xa545a5d1 == v0) {\n                    networkExchangeEnded();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xa9188878 == v0) {\n                    setPrimordialPrices(uint256,uint256);\n                }\n            } else if (0xb1e19d45 > v0) {\n                if (0xa99433a6 == v0) {\n                    aoDevTeam2();\n                } else if (0xa9b6b38e == v0) {\n                    theAO();\n                } else if (0xab13f751 == v0) {\n                    aoIonLotAddress();\n                } else if (0xab7f7706 == v0) {\n                    primordialTotalBought();\n                } else if (0xadc933cf == v0) {\n                    transferPrimordialFrom(address,address,uint256);\n                }\n            } else if (0xb1e19d45 == v0) {\n                whitelistBurnFrom(address,uint256);\n            } else if (0xb24626e9 == v0) {\n                setAODevTeamAddresses(address,address);\n            } else if (0xb414d4b6 == v0) {\n                frozenAccount(address);\n            } else if (0xb811ae7f == v0) {\n                transferPrimordial(address,uint256);\n            } else if (0xc3c1ac47 == v0) {\n                burnPrimordialFrom(address,uint256);\n            } else if (0xcae9ca51 == v0) {\n                approveAndCall(address,uint256,bytes);\n            }\n        } else if (0xe7c50185 > v0) {\n            if (0xd6830af3 > v0) {\n                if (0xcf3e194d == v0) {\n                    calculateMultiplierAfterConversion(address,uint256);\n                } else if (0xd1e5a552 == v0) {\n                    primordialAllowance(address,address);\n                } else if (0xd3183864 == v0) {\n                    calculateMultiplierAfterBurn(address,uint256);\n                } else if (0xd569aa25 == v0) {\n                    setAOETHAddress(address);\n                } else if (0xd64468bf == v0) {\n                    setAOIonLotAddress(address);\n                }\n            } else if (0xd6830af3 == v0) {\n                setSettingTAOId(address);\n            } else if (0xd6c9e189 == v0) {\n                mintEscrow(address,uint256);\n            } else if (0xd8ce52d1 == v0) {\n                namePublicKeyAddress();\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            } else if (0xe4849b32 == v0) {\n                sell(uint256);\n            } else if (0xe724529c == v0) {\n                freezeAccount(address,bool);\n            }\n        } else if (0xf81eb76d > v0) {\n            if (0xe7c50185 == v0) {\n                settingTAOId();\n            } else if (0xe9bb84c2 == v0) {\n                transferEth(address,uint256);\n            } else if (0xecbbd1ca == v0) {\n                calculateMaximumBurnAmount(address);\n            } else if (0xede5e884 == v0) {\n                approvePrimordialAndCall(address,uint256,bytes);\n            } else if (0xf2fde38b == v0) {\n                transferOwnership(address);\n            }\n        } else if (0xf81eb76d == v0) {\n            unstakePrimordialFrom(address,uint256,uint256);\n        } else if (0xf9f43634 == v0) {\n            buyPrimordial();\n        } else if (0xfaaad91d == v0) {\n            convertToPrimordial(uint256);\n        } else if (0xfb6ff161 == v0) {\n            availableETH();\n        } else if (0xfdb52e86 == v0) {\n            aoethAddress();\n        } else if (0xfff17e9e == v0) {\n            approvePrimordial(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 25.765717267990112,
	"usage": {
		"completion_tokens": 464,
		"prompt_tokens": 19982,
		"total_tokens": 20446
	}
}